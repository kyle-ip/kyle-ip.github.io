<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Python 异步编程总结 | YWH's Studio</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/2.0.4/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.css"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Python 异步编程总结</h1><a id="logo" href="/.">YWH's Studio</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Python 异步编程总结</h1><div class="post-meta">2020-02-06<span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4,216</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 20</span><span class="post-meta-item-text"> Minutes</span></span></span></div><div class="post-content"><h1 id="Select，回调，事件循环"><a href="#Select，回调，事件循环" class="headerlink" title="Select，回调，事件循环"></a>Select，回调，事件循环</h1><p>对于 Python 异步编程，需要先搞清楚以下这些概念：</p>
<ul>
<li>回调函数：提供函数供一定条件满足后调用（回调函数中都是非 I/O 操作，性能很高）；</li>
<li>事件循环：不断循环列表请求句柄状态，发现状态变化时执行回调函数；</li>
<li>单线程：驱动程序运行的 loop 是单线程运行（不会有内存消耗和切换问题）、非阻塞的，只会对就绪句柄执行回调函数，不会等待 I/O（除非所有句柄都在等待）。</li>
</ul>
<p>以一段简单的爬虫代码说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> DefaultSelector, EVENT_READ, EVENT_WRITE</span><br><span class="line"></span><br><span class="line">selector = DefaultSelector()        <span class="comment"># select 函数更高层次的封装，根据环境可以自动选择 select、poll 或 epoll</span></span><br><span class="line">urls = []</span><br><span class="line">stop = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fetcher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connected</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        回调函数</span></span><br><span class="line"><span class="string">        :param key:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 执行回调函数时，首先要对句柄取消注册</span></span><br><span class="line">        selector.unregister(key.fd)     </span><br><span class="line">        self.client.send(<span class="string">"GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n"</span>.format(self.path, self.host).encode(<span class="string">"utf8"</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注册句柄，监听读状态，执行回调函数 readable</span></span><br><span class="line">        selector.register(self.client.fileno(), EVENT_READ, self.readable)      </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readable</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        d = self.client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> d:</span><br><span class="line">            self.data += d</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            selector.unregister(key.fd)     <span class="comment"># 数据读取完成</span></span><br><span class="line">            data = self.data.decode(<span class="string">"utf8"</span>)</span><br><span class="line">            html_data = data.split(<span class="string">"\r\n\r\n"</span>)[<span class="number">1</span>]</span><br><span class="line">            print(html_data)</span><br><span class="line">            self.client.close()</span><br><span class="line">            urls.remove(self.spider_url)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> urls:</span><br><span class="line">                <span class="keyword">global</span> stop</span><br><span class="line">                stop = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_url</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        self.spider_url = url</span><br><span class="line">        url = urlparse(url)</span><br><span class="line">        self.host = url.netloc</span><br><span class="line">        self.path = url.path</span><br><span class="line">        self.data = <span class="string">b""</span></span><br><span class="line">        <span class="keyword">if</span> self.path == <span class="string">""</span>:</span><br><span class="line">            self.path = <span class="string">"/"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 建立 socket 连接</span></span><br><span class="line">        self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># select 需要非阻塞 I/O</span></span><br><span class="line">        self.client.setblocking(<span class="literal">False</span>)    </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.client.connect((self.host, <span class="number">80</span>))        </span><br><span class="line">        <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 注册句柄，当发生写事件时，执行回调函数 connected</span></span><br><span class="line">        selector.register(self.client.fileno(), EVENT_WRITE, self.connected)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 事件循环，不停请求 socket 的状态并调用对应的回调函数</span></span><br><span class="line">    <span class="comment"># select 本身是不支持 register 模式（selector 是对 select 的封装，提供了 register）</span></span><br><span class="line">    <span class="comment"># socket 状态变化以后的回调由程序员完成</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> stop:</span><br><span class="line">        ready = selector.select()</span><br><span class="line">        <span class="keyword">for</span> key, mask <span class="keyword">in</span> ready:</span><br><span class="line">            call_back = key.data        <span class="comment"># 执行注册时执行的回调函数</span></span><br><span class="line">            call_back(key)    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步</span></span><br><span class="line">fetcher = Fetcher()</span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    url = <span class="string">"http://shop.projectsedu.com/goods/&#123;&#125;/"</span>.format(url)</span><br><span class="line">    urls.append(url)</span><br><span class="line">    fetcher = Fetcher()</span><br><span class="line">    fetcher.get_url(url)</span><br><span class="line">loop()</span><br><span class="line">print(time.time() - start_time)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步（注意 self.client.setblocking(True)）</span></span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    url = <span class="string">"http://shop.projectsedu.com/goods/&#123;&#125;/"</span>.format(url)</span><br><span class="line">    get_(url)</span><br><span class="line">print(time.time() - start_time)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_socket_data</span><span class="params">()</span>:</span>      <span class="comment"># 模拟从 socket 中获取数据，唤醒 downloader</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"ywh"</span>             <span class="comment"># 如发生异常，则会抛出给 downloader</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloader</span><span class="params">(url)</span>:</span>        <span class="comment"># 主方法中不能添加耗时操作</span></span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client.setblocking(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        client.connect((host, <span class="number">80</span>))      <span class="comment"># 阻塞不会消耗 cpu</span></span><br><span class="line">    <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    selector.register(self.client.fileno(), EVENT_WRITE, self.connected)</span><br><span class="line">    source = <span class="keyword">yield</span> <span class="keyword">from</span> get_socket_data()       <span class="comment"># 暂停，直到 socket 获取到数据再往下执行</span></span><br><span class="line">    html_data = source.decode(<span class="string">"utf8"</span>).split(<span class="string">"\r\n\r\n"</span>)[<span class="number">1</span>]</span><br><span class="line">    print(html_data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_html</span><span class="params">(html)</span>:</span></span><br><span class="line">    html = <span class="keyword">yield</span> <span class="keyword">from</span> downloader()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 协程的调度：事件循环 + 协程模式（单线程）</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>



<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>使用以上 I/O 模型 API 存在以下问题：</p>
<ul>
<li>回调：代码可读性差，共享状态管理困难，异常处理困难；</li>
<li>多线程：线程间同步、锁并发性能差，线程创建消耗内存大、切换开销大；</li>
<li>同步：并发度低。</li>
</ul>
<p>因此可考虑使用协程：</p>
<ul>
<li>采用同步的方式编写异步（事件循环 + I/O 多路复用）代码代替回调，使用单线程切换任务（不再需要锁）；</li>
<li>自主编写调度函数，并发性能远高于线程间切换；</li>
<li>调度函数有多个入口：遇到 I/O 操作把当前函数暂停、切换到另一个函数执行，在适当时候恢复。</li>
<li>使用生成器（见“迭代器，生成器”）结合事件循环可实现协程；</li>
<li>协程 + 事件循环的效率不比回调 + 事件循环高，其目的在于简便地解决回调复杂的问题。</li>
</ul>
<p>为了将语义变得更加明确，Python 3.5 后引入了 async 和 await 关键词用于定义原生协程；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">downloader</span><span class="params">(url)</span>:</span>              <span class="comment"># 使用原生协程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ywh"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@types.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloader</span><span class="params">(url)</span>:</span>                    <span class="comment"># 使用生成器实现协程</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"ywh"</span>     </span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_url</span><span class="params">(url)</span>:</span>            <span class="comment"># async 和 await 必须成对使用</span></span><br><span class="line">    html = <span class="keyword">await</span> downloader(url)        <span class="comment"># await：执行费时操作（生成器不能直接用于 await，要加上装饰器或 async）</span></span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    coro = download_url(<span class="string">"http://www.test.com"</span>)</span><br><span class="line">    <span class="comment"># next(None)</span></span><br><span class="line">    coro.send(<span class="literal">None</span>)     <span class="comment"># 使用原生协程只能使用 send(None)</span></span><br></pre></td></tr></table></figure>

<p>使用生成器实现协程：</p>
<ul>
<li>一般的生成器只能作为生产者，实现为协程则可以消费外部传入的数据；</li>
<li>使用 <code>value = yield from xxx</code> 的生成器表示返回值给调用方、且调用方通过 send 方法传值给生成器函数；</li>
<li>主函数中不能添加耗时的逻辑，如把I/O操作通过 <code>yield from</code> 做异步处理；</li>
<li>最终实现通过同步的方式编写异步代码：在适当的时候暂停、恢复启动函数。</li>
</ul>
<p>获取生成器的状态：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ywh"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    gen = gen_func()</span><br><span class="line">    print(inspect.getgeneratorstate(gen))</span><br><span class="line">    next(gen)</span><br><span class="line">    print(inspect.getgeneratorstate(gen))</span><br></pre></td></tr></table></figure>

<p>实现协程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_func</span><span class="params">()</span>:</span></span><br><span class="line">    value = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ywh"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_socket_data</span><span class="params">()</span>:</span>      <span class="comment"># 模拟从 socket 中获取数据，唤醒 downloader</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"ywh"</span>             <span class="comment"># 如发生异常，则会抛出给 downloader</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloader</span><span class="params">(url)</span>:</span>        <span class="comment"># 主方法中不能添加耗时操作</span></span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client.setblocking(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        client.connect((host, <span class="number">80</span>))      <span class="comment"># 阻塞不会消耗 cpu</span></span><br><span class="line">    <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    selector.register(self.client.fileno(), EVENT_WRITE, self.connected)</span><br><span class="line">    source = <span class="keyword">yield</span> <span class="keyword">from</span> get_socket_data()       <span class="comment"># 暂停，直到 socket 获取到数据再往下执行</span></span><br><span class="line">    html_data = source.decode(<span class="string">"utf8"</span>).split(<span class="string">"\r\n\r\n"</span>)[<span class="number">1</span>]</span><br><span class="line">    print(html_data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_html</span><span class="params">(html)</span>:</span></span><br><span class="line">    html = <span class="keyword">yield</span> <span class="keyword">from</span> downloader()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 协程的调度：事件循环 + 协程模式（单线程）</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>



<h1 id="asyncio-简介"><a href="#asyncio-简介" class="headerlink" title="asyncio 简介"></a>asyncio 简介</h1><p>asyncio 模块：asyncio 是 Python 用于解决异步 I/O 编程的整套解决方案。</p>
<ul>
<li>高并发编程三个要素：事件循环+ I/O 多路复用 + 回调函数（驱动生成器，即协程）；</li>
<li>包括各种特定系统实现的模块化事件循环（select、poll、epoll）；</li>
<li>传输和协议抽象；</li>
<li>对TCP、UDP、SSL、子进程、延时调用以及其他的具体支持；</li>
<li>模仿 <code>futures</code> 模块但适用于事件循环使用的 Future 类；</li>
<li>基于 <code>yield from</code> 的协议和任务，可以顺序的方式编写并发代码；</li>
<li>必须使用一个将产生阻塞 I/O 的调用时，有接口可以把这个事件转义到线程池；</li>
<li>模仿 <code>threading</code> 模块中的同步原语、可以用在单线程的协程之间；</li>
<li>关键词 <code>async</code> 定义协程，<code>await</code> 异步调用。</li>
</ul>
<p>基于asyncio的框架：tornado（实现可直接部署的 web 服务器）、gevent、twisted（scrapy，django channels），使用这些框架必须有对应的异步驱动支持（如 tornado 中使用 pymysql 则不能异步）。</p>
<p>asyncio 具备以下特点：</p>
<ul>
<li>单线程，所有的函数调用都在 loop 中执行（如执行耗时操作则会等待完成后才执行下一个）；</li>
<li>使用 <code>await asyncio.sleep(2)</code> 与 <code>time.sleep(2)</code> 的区别是前者会立即返回一个 Future 对象，下次循环的时候判断这个是否已经过 2s，而不是阻塞等待。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义异步函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># time.sleep(5)   # 协程是单线程执行，time.sleep 是同步阻塞接口，不应在协程中实现</span></span><br><span class="line">    print(<span class="string">"end get url"</span>)</span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line">loop = asyncio.get_event_loop()     <span class="comment"># 创建事件循环（单线程：所有的函数调用都在 loop 中执行）</span></span><br><span class="line">tasks = [</span><br><span class="line">    get_html(<span class="string">"http://www.test.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)</span><br><span class="line">]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))    <span class="comment"># 类似 join，等待协程执行完成才往下执行</span></span><br><span class="line">print(time.time() - start_time)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="如何获取协程返回值？"><a href="#如何获取协程返回值？" class="headerlink" title="如何获取协程返回值？"></a>如何获取协程返回值？</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ywh"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(url, future)</span>:</span></span><br><span class="line">    print(url)</span><br><span class="line">    print(<span class="string">"send email to ywh"</span>)</span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># get_future = asyncio.ensure_future(get_html("http://www.test.com"))</span></span><br><span class="line">task = loop.create_task(get_html(<span class="string">"http://www.test.com"</span>))   <span class="comment"># 创建一个任务，返回 Future 对象</span></span><br><span class="line">task.add_done_callback(             </span><br><span class="line">    partial(callback, <span class="string">"http://www.test.com"</span>)           <span class="comment"># 把 callback 包装可接收参数的偏函数</span></span><br><span class="line">)       <span class="comment"># 执行 get_html，完成后调用回调函数 callback，最后再返回 get_html 的结果</span></span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line">print(task.result())        <span class="comment"># 获取 Future 对象的结果</span></span><br></pre></td></tr></table></figure>

<p>wait 与 gather：gather 是更高层次的封装，可以将 task 分组管理；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end get url"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [get_html(<span class="string">"http://www.test.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    <span class="comment"># loop.run_until_complete(asyncio.gather(*tasks))</span></span><br><span class="line">    <span class="comment"># print(time.time() - start_time)</span></span><br><span class="line"></span><br><span class="line">    group1 = [get_html(<span class="string">"http://projectsedu.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    group2 = [get_html(<span class="string">"http://www.test.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    </span><br><span class="line">    group1 = asyncio.gather(*group1)</span><br><span class="line">    group2 = asyncio.gather(*group2)</span><br><span class="line">    group2.cancel()</span><br><span class="line">    </span><br><span class="line">    loop.run_until_complete(asyncio.gather(group1, group2))</span><br><span class="line">    print(time.time() - start_time)</span><br></pre></td></tr></table></figure>

<h1 id="协程的取消，嵌套"><a href="#协程的取消，嵌套" class="headerlink" title="协程的取消，嵌套"></a>协程的取消，嵌套</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_forever()                  <span class="comment"># 一直运行不会停止</span></span><br><span class="line">loop.run_until_complete()           <span class="comment"># 运行指定协程后停止</span></span><br></pre></td></tr></table></figure>

<p>取消future(task)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(sleep_times)</span>:</span></span><br><span class="line">    print(<span class="string">"waiting"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sleep_times)</span><br><span class="line">    print(<span class="string">"done after &#123;&#125;s"</span>.format(sleep_times))</span><br><span class="line"></span><br><span class="line">tasks = [get_html(<span class="number">2</span>), get_html(<span class="number">3</span>), get_html(<span class="number">4</span>)]     <span class="comment"># 模拟三个执行时长不同的任务</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:                  <span class="comment"># 人为制造取消信号：捕捉键盘 ctrl + c 异常</span></span><br><span class="line">    all_tasks = asyncio.Task.all_tasks()        <span class="comment"># 不需要传入loop：自动从events.get_event_loop 中获取 loop，并获取 loop 中的所有 task</span></span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> all_tasks:                      <span class="comment"># 获取所有 tasks</span></span><br><span class="line">        print(task.cancel())                    <span class="comment"># 取消 task，返回取消结果</span></span><br><span class="line">    loop.stop()</span><br><span class="line">    loop.run_forever()      <span class="comment"># loop 调用 stop 后必须重新调用 run_forever，否则会抛出异常</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    loop.close()</span><br></pre></td></tr></table></figure>

<p>嵌套协程的调度过程（task -&gt; print_sum -&gt; compute）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># print_sum 协程嵌套 await_compute 协程</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(x, y)</span>:</span>                </span><br><span class="line">    print(<span class="string">"Compute %s + %s ..."</span> %(x, y))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1.0</span>)                    <span class="comment"># 3</span></span><br><span class="line">    <span class="keyword">return</span> x + y                                <span class="comment"># 4</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">print_sum</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    result = <span class="keyword">await</span> compute(x, y)                <span class="comment"># 2</span></span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"%s + %s = %s"</span> %(x, y, result))       <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(print_sum(<span class="number">1</span>, <span class="number">2</span>))        <span class="comment"># 1</span></span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>
<ol>
<li>创建 loop 和需要提交到 loop 的 task（通过 task 驱动协程执行），执行；</li>
<li>协程中的 await 相当于 yield from，在 task 和 compute 子协程之间建立一个通道，此时进入 compute 调度，print_sum 暂停；</li>
<li>子协程 compute 中的 await 表示暂停，不经过 print_sum、直接返回给 task 再返回给 loop，等待1s；</li>
<li>1s 过后，task 经通道询问 compute，compute 计算好结果值会抛出异常（StopIteration）并返回计算结果，compute 协程标记完成；</li>
<li>print_sum 捕捉到 compute 的异常、提取结果值，最后会把异常抛出给 task，print_sum 协程标记完成。</li>
</ol>
<h1 id="call-at，call-soon，call-later，call-soon-threadsafe"><a href="#call-at，call-soon，call-later，call-soon-threadsafe" class="headerlink" title="call_at，call_soon，call_later，call_soon_threadsafe"></a>call_at，call_soon，call_later，call_soon_threadsafe</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(sleep_times, loop)</span>:</span></span><br><span class="line">    print(<span class="string">"success time &#123;&#125;"</span>.format(loop.time()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stoploop</span><span class="params">(loop)</span>:</span></span><br><span class="line">    loop.stop()     </span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">now = loop.time()</span><br><span class="line">loop.call_at(now + <span class="number">2</span>, callback, <span class="number">2</span>, loop)    <span class="comment"># 当前时间的 2s 后执行</span></span><br><span class="line">loop.call_at(now + <span class="number">1</span>, callback, <span class="number">1</span>, loop)</span><br><span class="line">loop.call_at(now + <span class="number">3</span>, callback, <span class="number">3</span>, loop)</span><br><span class="line"><span class="comment"># loop.call_soon(stoploop, loop)              # 退出循环</span></span><br><span class="line">loop.call_soon(callback, <span class="number">4</span>, loop)           <span class="comment"># 立刻执行（在队列中等待到下一个循环即执行），另外还有 call_later</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理共享变量的线程安全问题可以使用 call_soon_threadsafe</span></span><br><span class="line">loop.run_forever()</span><br></pre></td></tr></table></figure>



<h1 id="如何在协程中集成线程池？"><a href="#如何在协程中集成线程池？" class="headerlink" title="如何在协程中集成线程池？"></a>如何在协程中集成线程池？</h1><p>在协程中集成阻塞 I/O：对于阻塞的库和接口（如 pymysql ），协程中要使用多线程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc</span><br><span class="line">    path = url.path</span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="comment"># client.setblocking(False)</span></span><br><span class="line">    client.connect((host, <span class="number">80</span>))  </span><br><span class="line">    client.send(<span class="string">"GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n"</span>.format(path, host).encode(<span class="string">"utf8"</span>))</span><br><span class="line">    data = <span class="string">b""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        d = client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> d:</span><br><span class="line">            data += d</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    data = data.decode(<span class="string">"utf8"</span>)</span><br><span class="line">    html_data = data.split(<span class="string">"\r\n\r\n"</span>)[<span class="number">1</span>]</span><br><span class="line">    print(html_data)</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">executor = ThreadPoolExecutor(<span class="number">3</span>)</span><br><span class="line">tasks = []</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    url = <span class="string">"http://shop.projectsedu.com/goods/&#123;&#125;/"</span>.format(url)</span><br><span class="line">    task = loop.run_in_executor(executor, get_url, url)     <span class="comment"># 指定线程池，将阻塞 I/O 操作放入 loop 中，不影响系统运行</span></span><br><span class="line">    <span class="comment"># 把线程中的 future 包装成协程的 future</span></span><br><span class="line">    tasks.append(task)</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">print(<span class="string">"last time:&#123;&#125;"</span>.format(time.time() - start_time))</span><br></pre></td></tr></table></figure>

<h1 id="模拟Http请求"><a href="#模拟Http请求" class="headerlink" title="模拟Http请求"></a>模拟Http请求</h1><p>requests 是同步的 http 请求模块，在 asyncio 不能达到异步的效果，而 asyncio 本身没有提供 http 协议的接口，可以使用 aiohttp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc</span><br><span class="line">    path = url.path</span><br><span class="line">    <span class="keyword">if</span> path == <span class="string">""</span>:</span><br><span class="line">        path = <span class="string">"/"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建立 socket 连接比较费时，使用 await</span></span><br><span class="line">    reader, writer = <span class="keyword">await</span> asyncio.open_connection(host, <span class="number">80</span>)</span><br><span class="line">    writer.write(<span class="string">"GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n"</span>.format(path, host).encode(<span class="string">"utf8"</span>))</span><br><span class="line">    all_lines = []</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> raw_line <span class="keyword">in</span> reader:    <span class="comment"># 异步化的 for 循环</span></span><br><span class="line">        data = raw_line.decode(<span class="string">"utf8"</span>)</span><br><span class="line">        all_lines.append(data)</span><br><span class="line">    html = <span class="string">"\n"</span>.join(all_lines)</span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    tasks = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        url = <span class="string">"http://shop.projectsedu.com/goods/&#123;&#125;/"</span>.format(url)</span><br><span class="line">        tasks.append(asyncio.ensure_future(get_url(url)))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.as_completed(tasks):</span><br><span class="line">        result = <span class="keyword">await</span> task</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(main())</span><br><span class="line">    print(<span class="string">'last time:&#123;&#125;'</span>.format(time.time() - start_time))</span><br></pre></td></tr></table></figure>

<h1 id="future-和-task"><a href="#future-和-task" class="headerlink" title="future 和 task"></a>future 和 task</h1><p>见 asyncio 源码</p>
<h1 id="同步与通信"><a href="#同步与通信" class="headerlink" title="同步与通信"></a>同步与通信</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Lock, Queue     <span class="comment"># await，区别于多线程的 Queue（阻塞）</span></span><br><span class="line"></span><br><span class="line">cache = &#123;&#125;</span><br><span class="line">queue = []      <span class="comment"># 协程是单线程，因此使用 list、dict 就可以实现通信，而不会有线程安全问题</span></span><br><span class="line">lock = Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_stuff</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="comment"># 如果没有同步机制，此处可能会被两个协程都对同一个 url 发起请求（耗时、被反爬）</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> lock:    <span class="comment"># 加锁，避免 parse_stuff 和 use_stuff 同时执行这部分代码</span></span><br><span class="line">    <span class="comment"># 由__await__、__aenter__实现，等价于await lock.acquire()、lock.release()</span></span><br><span class="line">        <span class="keyword">if</span> url <span class="keyword">in</span> cache:</span><br><span class="line">            <span class="keyword">return</span> cache[url]</span><br><span class="line">        stuff = <span class="keyword">await</span> aiohttp.request(<span class="string">'GET'</span>, url)</span><br><span class="line">        cache[url] = stuff</span><br><span class="line">        <span class="keyword">return</span> stuff</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse_stuff</span><span class="params">()</span>:</span></span><br><span class="line">    stuff = <span class="keyword">await</span> get_stuff()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">use_stuff</span><span class="params">()</span>:</span></span><br><span class="line">    stuff = <span class="keyword">await</span> get_stuff()</span><br><span class="line"></span><br><span class="line">tasks = [parse_stuff(), use_stuff()]    <span class="comment"># 当协程函数中没有 await，则会按加入 tasks 顺序执行</span></span><br></pre></td></tr></table></figure>

<p>实例：基于 asyncio 协程的高并发爬虫</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> aiomysql</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://www.lfd.uci.edu/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stop_flag = <span class="literal">False</span></span><br><span class="line">start_url = <span class="string">"http://www.jobbole.com/"</span></span><br><span class="line">waitting_urls = []</span><br><span class="line">seen_urls = set()</span><br><span class="line">sem = asyncio.Semaphore(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(url, session)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    发送 http请求</span></span><br><span class="line"><span class="string">    :param url:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> sem:                 <span class="comment"># 并发度控制</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)      <span class="comment"># 爬取速度控制</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">                print(<span class="string">'url statis: &#123;0&#125;'</span>.format(resp.status))</span><br><span class="line">                <span class="keyword">if</span> resp.status <span class="keyword">in</span> [<span class="number">200</span>, <span class="number">201</span>]:</span><br><span class="line">                    data = <span class="keyword">await</span> resp.text()</span><br><span class="line">                    <span class="keyword">return</span> data</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_urls</span><span class="params">(html)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    从请求页面中获取下次要请求 url</span></span><br><span class="line"><span class="string">    :param html:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    urls = []</span><br><span class="line">    pq = PyQuery(html)</span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> pq.items(<span class="string">'a'</span>):</span><br><span class="line">        url = link.attr(<span class="string">'href'</span>)</span><br><span class="line">        <span class="keyword">if</span> url <span class="keyword">and</span> url.startswith(<span class="string">'http'</span>) <span class="keyword">and</span> url <span class="keyword">not</span> <span class="keyword">in</span> seen_urls:</span><br><span class="line">            urls.append(url)</span><br><span class="line">            waitting_urls.append(url)</span><br><span class="line">    <span class="keyword">return</span> urls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">article_handler</span><span class="params">(url, session, pool)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取文章详情并解析入库</span></span><br><span class="line"><span class="string">    :param url:</span></span><br><span class="line"><span class="string">    :param session:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    html = <span class="keyword">await</span> fetch(url, session)</span><br><span class="line">    seen_urls.add(url)</span><br><span class="line">    extract_urls(html)</span><br><span class="line">    pq = PyQuery(html)</span><br><span class="line">    title = pq(<span class="string">'title'</span>).text()  <span class="comment"># 省略其他字段</span></span><br><span class="line">    print(title)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> pool.acquire() <span class="keyword">as</span> conn:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cur:</span><br><span class="line">            <span class="keyword">await</span> cur.execute(<span class="string">"sql"</span>)</span><br><span class="line">            insert_sql = <span class="string">"""</span></span><br><span class="line"><span class="string">                INSERT INTO xxx</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            print(cur.description)</span><br><span class="line">            <span class="keyword">await</span> cur.execute(insert_sql)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">init_urls</span><span class="params">(url, session)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    解析页面，</span></span><br><span class="line"><span class="string">    :param url:</span></span><br><span class="line"><span class="string">    :param session:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    html = <span class="keyword">await</span> fetch(url, session)</span><br><span class="line">    seen_urls.add(url)</span><br><span class="line">    extract_urls(html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(pool, session)</span>:</span></span><br><span class="line">    <span class="comment"># async with aiohttp.ClientSession() as session:      # 发送 http 请求需要的 session</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> stop_flag:</span><br><span class="line">        <span class="keyword">if</span> len(waitting_urls) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        url = waitting_urls.pop()</span><br><span class="line">        print(<span class="string">'start get url: '</span> + url)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 详情页协程，解析页面内容、入库</span></span><br><span class="line">        <span class="keyword">if</span> re.match(<span class="string">'http://.*?jobbole.com/\d+/'</span>, url):</span><br><span class="line">            <span class="keyword">if</span> url <span class="keyword">not</span> <span class="keyword">in</span> seen_urls:</span><br><span class="line">                asyncio.ensure_future(article_handler(url, session, pool))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 非详情页协程，进一步提取出详情页的url</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> url <span class="keyword">not</span> <span class="keyword">in</span> seen_urls:</span><br><span class="line">                asyncio.ensure_future(init_urls(url, session))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(loop)</span>:</span></span><br><span class="line">    <span class="comment"># 等待 MySQL 连接池建立</span></span><br><span class="line">    pool = <span class="keyword">await</span> aiomysql.create_pool(</span><br><span class="line">        host=<span class="string">''</span>, port=<span class="string">''</span>, user=<span class="string">''</span>, password=<span class="string">''</span>, db=<span class="string">'mysql'</span>, loop=loop, charset=<span class="string">'utf8'</span>, autocommit=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:      <span class="comment"># 发送 http 请求需要的 session</span></span><br><span class="line">        html = <span class="keyword">await</span> fetch(start_url, session)</span><br><span class="line">        seen_urls.add(start_url)</span><br><span class="line">        extract_urls(html)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># consumer 协程从 url 获取，动态向 asyncio 提交 article_handler 和 init_urls 协程</span></span><br><span class="line">        asyncio.ensure_future(consumer(pool, session))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    asyncio.ensure_future(main(loop))</span><br><span class="line">    loop.run_forever()</span><br></pre></td></tr></table></figure>



<p>以上。</p>
</div><div class="tags"><a href="/tags/%E6%8A%80%E6%9C%AF/"><i class="fa fa-tag"></i>技术</a><a href="/tags/Python/"><i class="fa fa-tag"></i>Python</a></div><div class="post-nav"><a class="pre" href="/2020/02/15/2020-02-15_diary/">疫情过后最想做的事</a><a class="next" href="/2020/02/03/JVM_jstat-monitor-analysis/">JVM jstat 监控分析</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC80ODYzMi8yNTEyNg=="><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://yipwinghong.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/%E6%9D%82%E4%BA%8B/" style="font-size: 15px;">杂事</a> <a href="/tags/%E6%8A%80%E6%9C%AF/" style="font-size: 15px;">技术</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 15px;">大数据</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/Kubernetes/" style="font-size: 15px;">Kubernetes</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" style="font-size: 15px;">信息安全</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/08/2020-04-08_diary/">关于使用思维导图做笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/28/Algorithm-leetcode-high-frequency-problems/">LeetCode 高频面试题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/06/InfoSecty_personal-infomation-security-guide/">個人信息安全保護指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/22/2020-02-22_diary/">免费 JetBrains 全家桶</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/15/DataWarehouse_design-basic/">数据仓库设计基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/15/Git_Cheat-Sheet/">Git Cheat Sheet</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/15/Docker&K8S_Cheat-Sheet/">Docker & K8S Cheat Sheet</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/15/2020-02-15_diary/">疫情过后最想做的事</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/06/Python_async-programming/">Python 异步编程总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/03/JVM_jstat-monitor-analysis/">JVM jstat 监控分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">YWH's Studio.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2d-widget-model-nietzsche"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>