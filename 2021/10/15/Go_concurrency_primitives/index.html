<!DOCTYPE html>
<html lang="en">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Kylo Yip">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Kylo Yip">
	
	<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
    <script src="/live2d-widget/autoload.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/>
	
    
    <meta name="keywords" content="Kylo's Notebook,Kylo Yip">
    
    <meta name="description" content="">
    <meta name="description" content="Go 标准库（sync）中提供了很多原生支持的并发原语，本文将简单讲解其基本用法。以及从 Go 标准库或第三方库扩展，实现更多复杂功能的并发原语。">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 并发原语">
<meta property="og:url" content="https://yipwinghong.github.io/2021/10/15/Go_concurrency_primitives/index.html">
<meta property="og:site_name" content="Kylo&#39;s Notebook">
<meta property="og:description" content="Go 标准库（sync）中提供了很多原生支持的并发原语，本文将简单讲解其基本用法。以及从 Go 标准库或第三方库扩展，实现更多复杂功能的并发原语。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-10-15T11:42:39.000Z">
<meta property="article:modified_time" content="2021-12-06T06:44:13.200Z">
<meta property="article:author" content="Kylo Yip">
<meta property="article:tag" content="技术">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    
    <title>Go 并发原语 · Kylo&#39;s Notebook</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20210204" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20210204" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js?v=20210204" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    <script src="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.3/js/all.min.js"  data-auto-replace-svg="nest" ></script>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Kylo's Notebook" type="application/atom+xml">
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <!-- top read progress line -->
    <div class="header-element">
        
        <div class="read-progress"></div>
        
    </div>
    <!-- sidebar menu button -->
    <div class="header-element">
        
        <div class="header-sidebar-menu header-sidebar-menu-rounded">
        
            
            <i class="fas fa-bars"></i>
            
        </div>
    </div>
    <!-- back to home page text -->
    <a class="home-link header-element" href=/>Kylo's Notebook</a>
    <!-- toggle banner for post layout -->
    
    
    <div class="banner">
    
        <div class="blog-title header-element">
            <a href="/" >Kylo&#39;s Notebook</a>
        </div>
        <div class="post-title header-element">
            <a href="#" class="post-name">Go 并发原语</a>
        </div>
    </div>
    
</header>
    
<footer class="footer-fixed">

    <!-- back to top button -->
    <div class="footer-fixed-element">
        
        <div class="back-top back-top-rounded">
        
            
            <i class="fas fa-chevron-up"></i>
            
        </div>
    </div>
</footer>
    <div class="wrapper">
        <div class="site-intro" style="







height:100vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(https://api.ixiaowai.cn/mcapi/mcapi.php)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Go 并发原语
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "技术">技术</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "Go">Go</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">17.3k</span>Reading time: <span class="post-count reading-time">76 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2021/10/15</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="Go-并发原语"><a href="#Go-并发原语" class="headerlink" title="Go 并发原语"></a>Go 并发原语</h1><p>Go 提供同步原语（Synchronization primitives，又称并发原语），常用于共享资源（互斥锁），编排任务（协程、等待组），传递消息（通道）。</p>
<h2 id="Mutex-互斥锁"><a href="#Mutex-互斥锁" class="headerlink" title="Mutex 互斥锁"></a>Mutex 互斥锁</h2><p><code>Mutex</code> 实现了 <code>Locker</code> 接口，提供互斥锁功能。以加锁、解锁操作用于限制 goroutine 访问临界区：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>如常见的 <code>count++</code> 操作（其汇编代码如下），非原子操作在并发场景下必然有资源竞争问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOVQ    &quot;&quot;.count(SB), AX    ; 读取 count 当前值</span><br><span class="line">LEAQ    1(AX), CX           ; 对值 +1</span><br><span class="line">MOVQ    CX, &quot;&quot;.count(SB)    ; 将结果重新写入</span><br></pre></td></tr></table></figure>

<p>因此引入 <code>Mutex</code> 才能确保多个 goroutine 并发执行 <code>count++</code> 的安全性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于确认所有的 goroutine 都完成</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</span><br><span class="line">                mu.Lock()</span><br><span class="line">                count++</span><br><span class="line">                mu.Unlock()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用基于 <a target="_blank" rel="noopener" href="https://github.com/google/sanitizers">sanitizers</a> 开发的 <a target="_blank" rel="noopener" href="https://blog.golang.org/race-detector">race detector</a> 工具，可在程序运行时监控对共享变量的非同步访问，打印警告信息。比如将上述代码中的 <code>Mutex</code> 去掉后运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">go run -race main.go</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># command-line-arguments</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .\main.go:10:9: mu declared but not used</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> E:\Project\<span class="built_in">test</span>\main&gt;go run -race main.go</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ==================</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> WARNING: DATA RACE</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Read at 0x00c00012e058 by goroutine 8:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   main.main.func1()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       E:/Project/<span class="built_in">test</span>/main/main.go:25 +0x84</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Previous write at 0x00c00012e058 by goroutine 7:</span>    </span><br><span class="line"><span class="meta">#</span><span class="bash">   main.main.func1()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       E:/Project/<span class="built_in">test</span>/main/main.go:25 +0x9d</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Goroutine 8 (running) created at:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   main.main()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       E:/Project/<span class="built_in">test</span>/main/main.go:20 +0xeb</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Goroutine 7 (running) created at:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   main.main()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       E:/Project/<span class="built_in">test</span>/main/main.go:20 +0xeb</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ==================</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 422886</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Found 1 data race(s)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exit</span> status 66</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其提示在源代码中的 25 行，有多个 goroutine 对内存地址 xxx 有并发读写行为。</span></span><br></pre></td></tr></table></figure>

<p>这种做法只能在运行时检测，但在生产环境中使用会有性能损耗。</p>
<p>另外是使用 go race detector，在编译时插入指令，在运行时通过指令检测并发读写从而发现 data race 问题。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -race -S main.go</span><br><span class="line"><span class="meta">#</span><span class="bash"> 0x002a 00042 (main.go:13)    CALL    runtime.racefuncenter(SB)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        ......</span></span><br><span class="line"><span class="meta">#</span><span class="bash">         0x0061 00097 (main.go:14)    JMP     173</span></span><br><span class="line"><span class="meta">#</span><span class="bash">         0x0063 00099 (main.go:15)    MOVQ    AX, <span class="string">&quot;&quot;</span>.j+8(SP)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">         0x0068 00104 (main.go:16)    PCDATA  <span class="variable">$0</span>, <span class="variable">$1</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">         0x0068 00104 (main.go:16)    MOVQ    <span class="string">&quot;&quot;</span>.&amp;count+128(SP), AX</span></span><br><span class="line"><span class="meta">#</span><span class="bash">         0x0070 00112 (main.go:16)    PCDATA  <span class="variable">$0</span>, <span class="variable">$0</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">         0x0070 00112 (main.go:16)    MOVQ    AX, (SP)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">         0x0074 00116 (main.go:16)    CALL    runtime.raceread(SB)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">         0x0079 00121 (main.go:16)    PCDATA  <span class="variable">$0</span>, <span class="variable">$1</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">         0x0079 00121 (main.go:16)    MOVQ    <span class="string">&quot;&quot;</span>.&amp;count+128(SP), AX</span></span><br><span class="line"><span class="meta">#</span><span class="bash">         0x0081 00129 (main.go:16)    MOVQ    (AX), CX</span></span><br><span class="line"><span class="meta">#</span><span class="bash">         0x0084 00132 (main.go:16)    MOVQ    CX, <span class="string">&quot;&quot;</span>..autotmp_8+16(SP)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">         0x0089 00137 (main.go:16)    PCDATA  <span class="variable">$0</span>, <span class="variable">$0</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">         0x0089 00137 (main.go:16)    MOVQ    AX, (SP)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">         0x008d 00141 (main.go:16)    CALL    runtime.racewrite(SB)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">         0x0092 00146 (main.go:16)    MOVQ    <span class="string">&quot;&quot;</span>..autotmp_8+16(SP), AX</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        ......</span></span><br><span class="line"><span class="meta">#</span><span class="bash">         0x00b6 00182 (main.go:18)    CALL    runtime.deferreturn(SB)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">         0x00bb 00187 (main.go:18)    CALL    runtime.racefuncexit(SB)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">         0x00c0 00192 (main.go:18)    MOVQ    104(SP), BP</span></span><br><span class="line"><span class="meta">#</span><span class="bash">         0x00c5 00197 (main.go:18)    ADDQ    <span class="variable">$112</span>, SP</span></span><br></pre></td></tr></table></figure>

<p><code>Mutex</code> 可以作为自定义 struct 的字段来控制其它字段的并发访问（对于多个字段，则把 Mutex 放在要控制的字段上，使用空格把字段分隔开来）；再把并发操作封装成方法，对外不需要暴露锁等逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> counter Counter</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</span><br><span class="line">                counter.Incr()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(counter.Count())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    CounterType <span class="keyword">int</span></span><br><span class="line">    Name        <span class="keyword">string</span></span><br><span class="line">    mu    sync.Mutex</span><br><span class="line">    count <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Incr</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    c.count++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Count</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="comment">// Go 1.14+ 对 defer 做了优化（采用更有效的内联方式，取代之前生成 defer 对象到 defer chain 中的做法），利用 defer 释放锁更合理：Lock 和 Unlock 总是成对出现。</span></span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p><code>Mutex</code> 利用 CAS 操作设置 <code>state</code> 标记（阻塞等待的 waiter 数量、饥饿标记、唤醒标记、持有状态标记）。</p>
<p><strong>申请者释放</strong>： <code>Mutex</code> 本身没有包含持有锁的 goroutine 的信息，Unlock 方法可以被任意 goroutine 调用释放锁（即使不是由它持有）。正因如此无法实现 <strong>可重入</strong>。</p>
<p>可能存在 goroutine 以为自己持有锁、但实际上已经被其它 goroutine 释放的情况，导致 data race 问题。因此建议谁申请谁释放，且不要跨方法加锁解锁。</p>
<p><strong>非公平竞争</strong>：已知取锁失败的 goroutine 会进入休眠，在锁释放后被唤醒、再次参与竞争。其中 CPU 中正在执行的 goroutine 有更多机会获取到锁，可减少上下文切换（甚至一个 goroutine 可以连续获得锁）。具体的处理逻辑如下：</p>
<table>
<thead>
<tr>
<th>goroutine</th>
<th>当前锁被持有</th>
<th>当前锁未被持有</th>
</tr>
</thead>
<tbody><tr>
<td>新加入的 goroutine</td>
<td>waiter++<br />休眠</td>
<td>获取锁</td>
</tr>
<tr>
<td>被唤醒的 goroutine</td>
<td>清除 mutexWoken 标记<br />重新休眠，加入等待队列</td>
<td>清除 mutexWoken 标记<br />获取锁</td>
</tr>
</tbody></table>
<p><strong>自旋锁</strong>：如果新加入的或被唤醒的 goroutine 首次获取不到锁，就会先执行一定次数的自旋（runtime 实现的 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/846dce9d05f19a1f53465e62a304dea21b99f910/src/runtime/proc.go#L5580">spin</a> 检查锁是否被释放），再执行原来的逻辑。当临界区代码较短，等待一小短时间来避免抢占、休眠和重新调度，进一步提高性能。</p>
<p><strong>避免饥饿</strong>：以上两条提高性能的措施，可能导致一些等待中的 goroutine 一直得不到锁。因此后续的版本中做了以下调整：</p>
<ul>
<li><p>  饥饿模式：非公平等待时间限制在 1ms，等待超过该阈值，则竞争时会被优待。</p>
</li>
<li><p>  修复“把唤醒 goroutine 放在等待队列尾部”导致不公平等待的 bug。</p>
</li>
<li><p>  将 fast path（正好得到锁）和 slow path（尝试自旋或参与竞争）拆成独立的方法以便内联，提高性能。</p>
</li>
<li><p>  调度器可以有更高优先级去执行 Mutex 唤醒后持有锁 waiter。</p>
</li>
<li><p>  …</p>
</li>
</ul>
<p>源码解析可参考：<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/295850">02 | Mutex：庖丁解牛看实现</a>。</p>
<h3 id="使用须知"><a href="#使用须知" class="headerlink" title="使用须知"></a>使用须知</h3><p><strong>Lock/Unlock 必须成对出现</strong>。一直不调用 <code>Unlock</code> 会导致死锁，对未加锁的 <code>Mutex</code> 调用 <code>Unlock</code> 会导致 panic。</p>
<p><code>Mutex</code> <strong>不可复用</strong>。sync 的同步原语都不能复制使用（比如作为参数传入），因为可能不是初始状态（<code>state</code> 标记）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    Count <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(c Counter)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 重复加锁。</span></span><br><span class="line">    c.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.Unlock()</span><br><span class="line">    fmt.Println(<span class="string">&quot;in foo&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Counter</span><br><span class="line">    c.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.Unlock()</span><br><span class="line">    c.Count++</span><br><span class="line">    <span class="comment">// 调用时将锁定状态的 Counter 传入。</span></span><br><span class="line">    foo(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可在编译时用 vet 工具（基于 <a target="_blank" rel="noopener" href="https://github.com/golang/tools/blob/master/go/analysis/passes/copylock/copylock.go">copylock</a> 静态分析）被检查出来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go vet main.go</span><br><span class="line"><span class="meta">#</span><span class="bash"> 分析函数调用、range 遍历、复制、声明、函数返回值等位置，是否出现锁 copy。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># command-line-arguments</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .\main.go:19:9: call of foo copies lock value: command-line-arguments.Counter</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .\main.go:23:12: foo passes lock by value: command-line-arguments.Counter</span></span><br></pre></td></tr></table></figure>

<p>另外 <code>Mutex</code> 是不可重入的，Go 标准库中没有提供可重入锁。要自行实现可参考：<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/296541">03｜Mutex：4种易错场景大盘点</a>。</p>
<h3 id="扩展：实现-TryLock"><a href="#扩展：实现-TryLock" class="headerlink" title="扩展：实现 TryLock"></a>扩展：实现 TryLock</h3><p>为 <code>Mutex</code> 添加 <code>TryLock</code> 的方法，实现尝试获取锁：即能取到就直接取用，否则就直接返回、不阻塞（后续可放弃操作，而不是一直阻塞）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    mutexLocked      = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 加锁标识位置（从 1 开始）</span></span><br><span class="line">    mutexWoken                   <span class="comment">// 唤醒标识位置</span></span><br><span class="line">    mutexStarving                <span class="comment">// 锁饥饿标识位置</span></span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span>      <span class="comment">// 标识 waiter 的起始 bit 位置</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TryLock 尝试获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">TryLock</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取锁的地址，从中可获取 state 的值。</span></span><br><span class="line">    addr := (*<span class="keyword">int32</span>)(unsafe.Pointer(&amp;m.Mutex))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fast path：如果能成功抢到锁，返回 true。</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(addr, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果处于唤醒、加锁或者饥饿状态，不参与竞争返回 false。</span></span><br><span class="line">    old := atomic.LoadInt32(addr)</span><br><span class="line">    <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving|mutexWoken) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试在竞争的状态下请求锁</span></span><br><span class="line">    <span class="built_in">new</span> := old | mutexLocked</span><br><span class="line">    <span class="keyword">return</span> atomic.CompareAndSwapInt32(addr, old, <span class="built_in">new</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 goroutine，在一段时间持有锁。</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    time.Sleep(time.Duration(rand.Intn(<span class="number">2</span>)) * time.Second)</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试获取到锁</span></span><br><span class="line"><span class="keyword">if</span> mu.TryLock()  &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;got the lock&quot;</span>)</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有获取到</span></span><br><span class="line">fmt.Println(<span class="string">&quot;can&#x27;t get the lock&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="扩展：获取-Waiter-数量等指标"><a href="#扩展：获取-Waiter-数量等指标" class="headerlink" title="扩展：获取 Waiter 数量等指标"></a>扩展：获取 Waiter 数量等指标</h3><p>如同上面的方法利用 <code>unsafe.Pointer</code> 获取锁地址，再从前 4 字节中得到 <code>state</code> 字段的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="keyword">int32</span></span><br><span class="line">    sema  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu Mutex</span><br><span class="line">state := atomic.LoadInt32((*<span class="keyword">int32</span>)(unsafe.Pointer(&amp;m.Mutex)))</span><br></pre></td></tr></table></figure>

<p>其中 <code>state</code> 字段共有四个标记：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[mutexWaiters]</span><span class="selector-attr">[mutexStarving]</span><span class="selector-attr">[mutexWoken]</span><span class="selector-attr">[mutexLocked]</span></span><br><span class="line">阻塞 waiter 数     饥饿标记       唤醒标记    锁持有标记</span><br></pre></td></tr></table></figure>

<p>在 <code>Mutex</code> 的源码中可见，<code>mutexWaiterShift</code> 值为 3：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    mutexLocked      = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 1 加锁标识位置</span></span><br><span class="line">    mutexWoken                   <span class="comment">// 2 唤醒标识位置</span></span><br><span class="line">    mutexStarving                <span class="comment">// 4 锁饥饿标识位置</span></span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span>      <span class="comment">// 3 标识 waiter 的起始 bit 位置</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>因此将 <code>state</code> 右移 3 位即可得到当前 waiter 的数量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waiterCount := state &gt;&gt; mutexWaiterShift</span><br></pre></td></tr></table></figure>

<p>如果当前锁已被其他 goroutine 持有，则还需要加上 1：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waiterCount = waiterCount + (waiterCount &amp; mutexLocked)    <span class="comment">// 再加上锁持有者的数量，0 或 1</span></span><br></pre></td></tr></table></figure>

<p>同理可取得 <strong>锁是否被持有</strong>、<strong>是否有等待者被唤醒</strong>、<strong>是否处于饥饿状态</strong> 的信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Count</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    v := atomic.LoadInt32((*<span class="keyword">int32</span>)(unsafe.Pointer(&amp;m.Mutex)))</span><br><span class="line">    v = v &gt;&gt; mutexWaiterShift</span><br><span class="line">    v = v + (v &amp; mutexLocked)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">IsLocked</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    state := atomic.LoadInt32((*<span class="keyword">int32</span>)(unsafe.Pointer(&amp;m.Mutex)))</span><br><span class="line">    <span class="keyword">return</span> state&amp;mutexLocked == mutexLocked</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">IsWoken</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    state := atomic.LoadInt32((*<span class="keyword">int32</span>)(unsafe.Pointer(&amp;m.Mutex)))</span><br><span class="line">    <span class="keyword">return</span> state&amp;mutexWoken == mutexWoken</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">IsStarving</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    state := atomic.LoadInt32((*<span class="keyword">int32</span>)(unsafe.Pointer(&amp;m.Mutex)))</span><br><span class="line">    <span class="keyword">return</span> state&amp;mutexStarving == mutexStarving</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu Mutex</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        mu.Lock()</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        mu.Unlock()</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Printf(<span class="string">&quot;waitings: %d, isLocked: %t, woken: %t, starving: %t\n&quot;</span>, mu.Count(), mu.IsLocked(), mu.IsWoken(), mu.IsStarving())</span><br></pre></td></tr></table></figure>

<h3 id="扩展：实现线程安全队列"><a href="#扩展：实现线程安全队列" class="headerlink" title="扩展：实现线程安全队列"></a>扩展：实现线程安全队列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NonBlockingQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    data []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    mu   sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlockingQueue</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(q *NonBlockingQueue)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;NonBlockingQueue&#123;data: <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, n)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *NonBlockingQueue)</span> <span class="title">Add</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    q.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> q.mu.Unlock()</span><br><span class="line">    q.data = <span class="built_in">append</span>(q.data, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *NonBlockingQueue)</span> <span class="title">Poll</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    q.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(q.data) == <span class="number">0</span> &#123;</span><br><span class="line">        q.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    v := q.data[<span class="number">0</span>]</span><br><span class="line">    q.data = q.data[<span class="number">1</span>:]</span><br><span class="line">    q.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RWMutex-读写锁"><a href="#RWMutex-读写锁" class="headerlink" title="RWMutex 读写锁"></a>RWMutex 读写锁</h2><p>读写分离：在读多写少的场景下，区分读写操作、只对写操作加锁，以提高读性能（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem">Readers–writers problem</a>）。</p>
<p>Go 标准库提供 <code>RWMutex</code>，在某一时刻只能由任意数量的 reader 持有，或者是只被单个的 writer 持有。</p>
<ul>
<li><p>  <code>Lock</code> 和 <code>Unlock</code>：写时调用，如锁已被 reader 或者 writer 持有，<code>Lock</code> 会一直阻塞直到能获取到锁。</p>
</li>
<li><p>  <code>RLock</code> 和 <code>RUnlock</code>：读时调用。如锁已被 writer 持有，<code>RLock</code> 方法会一直阻塞直到能获取到锁，否则就直接返回。</p>
</li>
<li><p>  <code>RLocker</code>：为读操作返回一个 <code>Locker</code> 接口对象。其 <code>Lock</code> 方法会调用 <code>RWMutex</code> 的 <code>RLock</code> 方法，<code>Unlock</code> 方法会调用 <code>RWMutex</code> 的 <code>RUnlock</code> 方法。</p>
</li>
</ul>
<p>以封装一个线程安全的计数器为例，在读时（<code>Count</code>）加读锁、写时（<code>Incr</code>）加写锁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.RWMutex</span><br><span class="line">    count <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Incr</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    c.count++</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Count</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">    c.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> counter Counter</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                counter.Count() 				<span class="comment">// 读频率 1次/ms</span></span><br><span class="line">                time.Sleep(time.Millisecond)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        counter.Incr()							<span class="comment">// 写频率 1次/s</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RWMutex</code> 是基于 <code>Mutex</code> 实现的，其对写操作优先，即如果已有 writer 在等待请求锁（阻塞的 <code>Lock</code> 调用），则会阻止新的 reader 获取锁，优先保障 writer（注意不是抢占）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w           Mutex   <span class="comment">// 互斥锁</span></span><br><span class="line">    writerSem   <span class="keyword">uint32</span>  <span class="comment">// writer 信号量</span></span><br><span class="line">    readerSem   <span class="keyword">uint32</span>  <span class="comment">// reader 信号量</span></span><br><span class="line">    readerCount <span class="keyword">int32</span>   <span class="comment">// reader 数量（&lt;0 表示有 writer 等待锁或占用）</span></span><br><span class="line">    readerWait  <span class="keyword">int32</span>   <span class="comment">// writer 等待完成的 reader 数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br></pre></td></tr></table></figure>

<h3 id="实现细节-1"><a href="#实现细节-1" class="headerlink" title="实现细节"></a>实现细节</h3><p><code>RLock</code> 和 <code>RUnlock</code>：</p>
<ul>
<li><p>  在加锁时先对 <code>readerCount</code> +1。如仍 &lt;0 则表示有 writer 等待锁，请求的 reader 会阻塞等待锁的释放。</p>
</li>
<li><p>  在解锁时先对 <code>readerCount</code> -1。如仍 &lt;0 则表示有 writer 等待锁，检查是否所有 reader 都释放了读锁，是则唤醒请求写锁的 writer；否则 writer 等待所有 reader 释放完（writer 的优先只是针对新参加竞争的 reader 而言）。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 加锁时 reader 数 +1，如果值仍 &lt;0，表示有 writer 等待请求锁。</span></span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 由于 writer 优先级高，后来的 reader 都会阻塞休眠。</span></span><br><span class="line">        runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 解锁时 reader 量 -1，如果值仍 &lt;0，表示当前有 writer 竞争锁。</span></span><br><span class="line">    <span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 检查是否 reader 都释放读锁，是则唤醒请求写锁的 writer。</span></span><br><span class="line">        rw.rUnlockSlow(r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">rUnlockSlow</span><span class="params">(r <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 此为最后一个 reader，writer 可以获得锁。</span></span><br><span class="line">        runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Lock</code>：</p>
<ul>
<li><p>  writer 之间也有竞争，因此 writer 要取得获得内部的互斥锁。</p>
</li>
<li><p>  随后反转 <code>readerCount</code> 字段（<code>readerCount - rwmutexMaxReaders</code>，因此 <code>readerCount</code> 还表示当前有 writer 占有或等待）。</p>
</li>
<li><p>  如果发现此时锁正被 reader 占用，则把值保存在 <code>readerWait</code>，writer 进入阻塞；每当 reader 调用 <code>RUnlock</code> 释放读锁 <code>readerWait</code> -1，直到所有 reader 都释放，则唤醒该 writer。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 取得获得内部的互斥锁，解决其他 writer 竞争问题。</span></span><br><span class="line">    rw.w.Lock()</span><br><span class="line">    <span class="comment">// 反转 readerCount，告知 reader 此时有 writer 竞争锁。</span></span><br><span class="line">    <span class="comment">// 当前活跃的 reader 数量：即持有读锁未释放。</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有 reader 持有锁就需要等待：需要把当前 readerCount 保存到 readerWait 字段保存，并使 writer 阻塞。</span></span><br><span class="line">    <span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">        runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Unlock</code>：</p>
<ul>
<li><p>  占用锁的 writer 在释放时再反转 <code>readerCount</code> 字段，唤醒新加入竞争、阻塞的 reader。</p>
</li>
<li><p>  最后再释放内部的互斥锁，允许其它 writer 参与竞争。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 告知 reader 此时没有活跃的 writer，并唤醒。</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;</span><br><span class="line">        runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放内部的互斥锁</span></span><br><span class="line">    rw.w.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用须知-1"><a href="#使用须知-1" class="headerlink" title="使用须知"></a>使用须知</h3><p>与 <code>Mutex</code> 类似，<code>RWMutex</code> 也是不可复制、重入、未加锁先解锁，但其出现死锁的情况更复杂。</p>
<p>比如当有活跃 reader 时，writer 会等待，如果在 reader 的读操作中调用 writer 的写操作，reader 和 writer 就会形成互相依赖的死锁状态。</p>
<p>又比如 writer 请求锁时已经有活跃的 reader，它会等待活跃的 reader 完成才获取到锁，但是之后活跃的 reader 再依赖新的 reader，新的 reader 就会等待 writer 释放锁之后才能执行，此时就会形成循环依赖。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形成循环等待：</span></span><br><span class="line"><span class="comment">// writer 依赖活跃的 reader，活跃的 reader 依赖新来的 reader（等待退递归时释放），新来的 reader 依赖 writer。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 请求写锁（先等待 200ms，此时 factorial 在不断递归调用读锁）</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">200</span> * time.Millisecond)</span><br><span class="line">        mu.Lock()</span><br><span class="line">        fmt.Println(<span class="string">&quot;Lock&quot;</span>)</span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        mu.Unlock()</span><br><span class="line">        fmt.Println(<span class="string">&quot;Unlock&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        factorial(&amp;mu, <span class="number">10</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(m *sync.RWMutex, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;RLock&quot;</span>)</span><br><span class="line">    <span class="comment">// 请求读锁</span></span><br><span class="line">    m.RLock()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;RUnlock&quot;</span>)</span><br><span class="line">        m.RUnlock()</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    <span class="comment">// 递归执行，不断产生对读锁的调用。</span></span><br><span class="line">    <span class="keyword">return</span> factorial(m, n<span class="number">-1</span>) * n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WaitGroup-等待组"><a href="#WaitGroup-等待组" class="headerlink" title="WaitGroup 等待组"></a>WaitGroup 等待组</h2><p><code>WaitGroup</code> 用于解决并发等待问题，类似 Java 的 <code>CountDownLatch</code> 和 <code>CycliBarrier</code>。比如任务 A 中间需要等待并行的任务 B1、B2、B3 都完成才能继续执行，使用阻塞等待可以避免对 B 的轮询，一是实时性得到保证，二是避免空耗 CPU。</p>
<p>其包含三个方法：</p>
<ul>
<li><p>  <code>Add</code>：设置计数值。</p>
</li>
<li><p>  <code>Done</code>：计数值减 1（即 <code>Add(-1)</code>）。</p>
</li>
<li><p>  <code>Wait</code>：阻塞当前 goroutine，直到计数值变为 0。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.Mutex</span><br><span class="line">    count <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Incr</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    c.count++</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Count</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> counter Counter</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">            counter.Incr()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// checkpoint：等待 goroutine 都完成。</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(counter.Count())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现细节-2"><a href="#实现细节-2" class="headerlink" title="实现细节"></a>实现细节</h3><p><code>WaitGroup</code> 内部：</p>
<ul>
<li><p>  <code>noCopy</code> ：辅助 vet 工具检查是否该 <code>WaitGroup</code> 是否复制使用。</p>
</li>
<li><p>  <code>state1</code>：包含计数、阻塞在检查点的 waiter 数和信号量。</p>
</li>
</ul>
<blockquote>
<p>  对于自定义结构，也可以通过嵌入 <code>noCopy</code> 实现 vet 检查。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line">    state1 [<span class="number">3</span>]<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到 state 的地址和信号量的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">state</span><span class="params">()</span> <span class="params">(statep *<span class="keyword">uint64</span>, semap *<span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 地址是 64bit 对齐，数组前两个元素用作 state，后一个元素做信号量。</span></span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class="number">2</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 地址是 32bit 对齐，数组后两个元素用作 state，可用来做 64bit 原子操作，第一个元素 32bit 用作信号量。</span></span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class="number">1</span>])), &amp;wg.state1[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">64</span> 位对齐</span><br><span class="line">state1<span class="selector-attr">[0]</span>    state1<span class="selector-attr">[1]</span>    state1<span class="selector-attr">[2]</span></span><br><span class="line">waiter 数    计数值        信号量</span><br><span class="line"></span><br><span class="line"><span class="number">32</span> 位对齐</span><br><span class="line">          <span class="number">64</span> 位对齐</span><br><span class="line">          ↓ </span><br><span class="line">state1<span class="selector-attr">[0]</span>    state1<span class="selector-attr">[1]</span>    state1<span class="selector-attr">[2]</span></span><br><span class="line">信号量        waiter 数    计数值 </span><br></pre></td></tr></table></figure>

<p><code>Add</code> 和 <code>Done</code>：操作的是 <code>state</code> 的计数部分。可为计数值增加一个 delta 值，内部通过原子操作把该值加到计数值上。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    statep, semap := wg.state()</span><br><span class="line">    <span class="comment">// 高 32bit 是计数值，所以把 delta 左移 32，增加到计数上。</span></span><br><span class="line">    state := atomic.AddUint64(statep, <span class="keyword">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">    v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>) </span><br><span class="line">    w := <span class="keyword">uint32</span>(state)</span><br><span class="line">    <span class="comment">// 如果计数值大于 0，且没有 waiter，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state 为 waiter 的数量：将 waiter 数量设置为 0，与计数值组合 *statep 直接设置为0。此时唤醒所有 waiter。</span></span><br><span class="line">    *statep = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">        runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Wait</code>：不断检查 state 的值。如果计数值为 0，即所有任务完成，直接返回。否则调用者变成等待者、加入 waiter 队列并阻塞。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">    statep, semap := wg.state()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 期间 wait 可能被并发调用，因此循环执行。</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        state := atomic.LoadUint64(statep)</span><br><span class="line">        <span class="comment">// 取当前计数值和 waiter 数量</span></span><br><span class="line">        v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">        w := <span class="keyword">uint32</span>(state)</span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 计数值为 0, 调用方法的 goroutine 不必等待，继续执行。</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则 waiter 数量 +1。</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞休眠等待，直到被唤醒返回。</span></span><br><span class="line">            runtime_Semacquire(semap)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用须知-2"><a href="#使用须知-2" class="headerlink" title="使用须知"></a>使用须知</h3><ul>
<li><p>  由于 <code>Add</code> 可以传入负数（或多次调用 <code>Done</code>），当内部计数值 &lt; 0，则会导致 panic。</p>
</li>
<li><p>  虽然 <code>Add</code> 可以在运行过程中增加计数值，但也建议预设，即确保 <code>Wait</code> 方法必须在所有 <code>Add</code> 方法调用之后才调用。</p>
</li>
<li><p>  另外如果需要重用 <code>WaitGroup</code>（比如类似 Java <code>CycliBarrier</code>），必须确保 <code>Wait</code> 结束后才重置 <code>WaitGroup</code> 的值，否则会导致 panic。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Millisecond)</span><br><span class="line">        wg.Done()</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">     <span class="comment">// 主 goroutine 等待，有可能和第 8 行并发执行。</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Cond-条件"><a href="#Cond-条件" class="headerlink" title="Cond 条件"></a>Cond 条件</h2><p>一组 goroutine 等待某个条件（bool 变量），条件满足时其中一个或者所有 goroutine 被唤醒执行。其包括以下方法：</p>
<ul>
<li>  <code>Signal</code>：调用者唤醒一个等待此 <code>Cond</code> 的 goroutine。如果 <code>Cond</code> 等待队列有一或多个等待的 goroutine，则从等待队列中移除第一个并把它唤醒（即其他语言的 <code>notify</code>）。</li>
<li>  <code>Broadcast</code>：调用者唤醒所有等待此 <code>Cond</code> 的 goroutine（即其它语言的 <code>notifyAll</code>）。</li>
<li>  <code>Wait</code>：把调用者放入 <code>Cond</code> 等待队列中并阻塞，直到被 <code>Signal</code> 或 <code>Broadcast</code> 从等待队列中移除并唤醒（注意唤醒后要检查条件）。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NeWCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">    <span class="keyword">var</span> ready <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            time.Sleep(time.Duration(rand.Int63n(<span class="number">10</span>)) * time.Second)</span><br><span class="line">            <span class="comment">// 加锁更改等待条件</span></span><br><span class="line">            c.L.Lock()</span><br><span class="line">            ready++</span><br><span class="line">            c.L.Unlock()</span><br><span class="line"></span><br><span class="line">            log.Printf(<span class="string">&quot;goroutine #%d 已准备就绪\n&quot;</span>, i)</span><br><span class="line">            <span class="comment">// 广播唤醒所有的等待者</span></span><br><span class="line">            c.Broadcast()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    c.L.Lock()</span><br><span class="line">    <span class="keyword">for</span> ready != <span class="number">10</span> &#123;</span><br><span class="line">        c.Wait()</span><br><span class="line">        log.Println(<span class="string">&quot;指挥者被唤醒一次&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c.L.Unlock()</span><br><span class="line">    log.Println(<span class="string">&quot;条件满足，开始执行...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现细节-3"><a href="#实现细节-3" class="headerlink" title="实现细节"></a>实现细节</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line">    <span class="comment">// 当观察或者修改等待条件时要加锁</span></span><br><span class="line">    L Locker</span><br><span class="line">    <span class="comment">// 等待队列</span></span><br><span class="line">    notify  notifyList</span><br><span class="line">    <span class="comment">// 运行时检查 Cond 是否被复制使用。</span></span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Cond&#123;L: l&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.checker.check()</span><br><span class="line">    <span class="comment">// 添加到等待队列中</span></span><br><span class="line">    t := runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line">    c.L.Unlock()</span><br><span class="line">    <span class="comment">// 阻塞休眠直到被唤醒</span></span><br><span class="line">    runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line">    c.L.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.checker.check()</span><br><span class="line">    runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.checker.check()</span><br><span class="line">    runtime_notifyListNotifyAll(&amp;c.notify）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Wait</code> 把调用者加入等待队列并释放锁，被唤醒之后还会请求锁。在阻塞休眠期间，调用者不持有锁，可使其他 goroutine 有机会检查或者更新等待变量。等调用者被唤醒之后再去争抢这把锁。</p>
<h3 id="使用须知-3"><a href="#使用须知-3" class="headerlink" title="使用须知"></a>使用须知</h3><p>调用 <code>Wait</code> 时必须加锁，否则可能导致 <code>Unlock</code> 一个未加锁的 <code>Locker</code>。</p>
<p>调用 <code>Wait</code> 必须检查等待条件是否满足，只有满足才执行。</p>
<p>Go 提供的 <code>Channel</code> 和 <code>WaitGroup</code> 是更广泛使用的通知机制，在 wait-notify 场景下比 <code>Cond</code> 更实用。而 <code>Cond</code> 独有的特点在于：</p>
<ul>
<li><p>  和一个 <code>Locker</code> 关联，可对相关的依赖条件更改提供保护。</p>
</li>
<li><p>  同时支持 <code>Signal</code> 和 <code>Broadcast</code>，而 <code>Channel</code> 只能同时支持一种。</p>
</li>
<li><p>  <code>Broadcast</code> 可被重复调用。等待条件变成不满足后，又可以调用 <code>Broadcast</code> 再次唤醒等待的 goroutine。而 <code>Channel</code> 被 <code>close</code> 后不能再使用。</p>
</li>
</ul>
<h3 id="扩展：实现阻塞队列"><a href="#扩展：实现阻塞队列" class="headerlink" title="扩展：实现阻塞队列"></a>扩展：实现阻塞队列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BlockingQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    cond     *sync.Cond</span><br><span class="line">    data     []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    capacity <span class="keyword">int</span></span><br><span class="line">    logs     []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewQueue</span><span class="params">(capacity <span class="keyword">int</span>)</span> *<span class="title">BlockingQueue</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;BlockingQueue&#123;</span><br><span class="line">        cond:     &amp;sync.Cond&#123;L: &amp;sync.Mutex&#123;&#125;&#125;,</span><br><span class="line">        data:     <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>),</span><br><span class="line">        capacity: capacity, logs: <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *BlockingQueue)</span> <span class="title">Add</span><span class="params">(d <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    q.cond.L.Lock()</span><br><span class="line">    <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q.data) == q.capacity &#123;</span><br><span class="line">        q.cond.Wait()</span><br><span class="line">    &#125;</span><br><span class="line">    q.data = <span class="built_in">append</span>(q.data, d)</span><br><span class="line">    <span class="comment">// 记录操作日志</span></span><br><span class="line">    q.logs = <span class="built_in">append</span>(q.logs, fmt.Sprintf(<span class="string">&quot;En %v\n&quot;</span>, d))</span><br><span class="line">    <span class="comment">// 通知其他 waiter 进行 Poll 或 Add 操作</span></span><br><span class="line">    q.cond.Broadcast()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *BlockingQueue)</span> <span class="title">Poll</span><span class="params">()</span> <span class="params">(d <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    q.cond.L.Lock()</span><br><span class="line">    <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q.data) == <span class="number">0</span> &#123;</span><br><span class="line">        q.cond.Wait()</span><br><span class="line">    &#125;</span><br><span class="line">    d = q.data[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    q.data = q.data[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录操作日志</span></span><br><span class="line">    q.logs = <span class="built_in">append</span>(q.logs, fmt.Sprintf(<span class="string">&quot;De %v\n&quot;</span>, d))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知其他 waiter 进行 Poll 或 Add 操作</span></span><br><span class="line">    q.cond.Broadcast()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *BlockingQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    q.cond.L.Lock()</span><br><span class="line">    <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(q.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *BlockingQueue)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b strings.Builder</span><br><span class="line">    <span class="keyword">for</span> _, log := <span class="keyword">range</span> q.logs &#123;</span><br><span class="line">        <span class="comment">//fmt.Fprint(&amp;b, log)</span></span><br><span class="line">        b.WriteString(log)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Once-单例"><a href="#Once-单例" class="headerlink" title="Once 单例"></a>Once 单例</h2><p>线程安全的单例一般用于初始化资源，可通过 package 级别的变量或 <code>init</code> 函数实现。</p>
<p>在创建资源（比如数据库连接等）要确保线程安全，使用懒汉式加锁的方式会有性能问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> connMu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> conn net.Conn</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getConn</span><span class="params">()</span> <span class="title">net</span>.<span class="title">Conn</span></span> &#123;</span><br><span class="line">    connMu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> connMu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> conn != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> conn</span><br><span class="line">    &#125;</span><br><span class="line">    conn, _ = net.DialTimeout(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;baidu.com:80&quot;</span>, <span class="number">10</span>*time.Second)</span><br><span class="line">    <span class="keyword">return</span> conn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn := getConn()</span><br><span class="line">    <span class="keyword">if</span> conn == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;conn is nil&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 <code>Once</code> 提供的 <code>func (o *Once) Do(f func())</code> 可确保多次调用中只有第一次调用时 <code>f</code> 函数才会执行（哪怕后来重新传入 <code>f</code> 参数再执行）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> once sync.Once</span><br><span class="line">    f1 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;in f1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    once.Do(f1) <span class="comment">// in f1</span></span><br><span class="line"></span><br><span class="line">    a := <span class="string">&quot;xxx&quot;</span>  <span class="comment">// 闭包</span></span><br><span class="line">    f2 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(a + <span class="string">&quot;in f2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    once.Do(f2) <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现细节-4"><a href="#实现细节-4" class="headerlink" title="实现细节"></a>实现细节</h3><p>自己实现 <code>Once</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    done <span class="keyword">uint32</span></span><br><span class="line">    m    Mutex</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 双重校验</span></span><br><span class="line">    <span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果有并发的 goroutine，可进入 doSlow。</span></span><br><span class="line">        o.doSlow(f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">doSlow</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    o.m.Lock()</span><br><span class="line">    <span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">    <span class="comment">// 再校验一次，否则可能存在后续调用 Do 方法的 goroutine 看到 done 已被设置，但获取资源时候可能会得到空，因为 f 未执行完。</span></span><br><span class="line">    <span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用须知-4"><a href="#使用须知-4" class="headerlink" title="使用须知"></a>使用须知</h3><p>由于 <code>f</code> 方法是无参无返回值的，当执行时 panic 或初始化资源失败，<code>Once</code> 还是会认为初次执行已成功，再次调用 <code>Do</code> 方法也不会再次执行 <code>f</code>。</p>
<p>可以自己实现 <code>Once</code>，既返回当前调用 <code>Do</code> 方法是否成功，还可以在初始化失败后调用 <code>Do</code> 方法再次尝试初始化直到成功。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    m    sync.Mutex</span><br><span class="line">    done <span class="keyword">uint32</span>        <span class="comment">// 1 表示初始化。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入函数 f 有返回值 error，用于初始化失败时返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// fast path</span></span><br><span class="line">    <span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">1</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果未初始化则执行 slowDo。</span></span><br><span class="line">    <span class="keyword">return</span> o.slowDo(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">slowDo</span><span class="params">(f <span class="keyword">func</span>()</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">    o.m.Lock()</span><br><span class="line">    <span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="comment">// 再校验一次，否则可能存在后续调用 Do 方法的 goroutine 看到 done 已被设置，但获取资源时候可能会得到空，因为 f 未执行完。</span></span><br><span class="line">    <span class="keyword">if</span> o.done == <span class="number">0</span> &#123; </span><br><span class="line">        err = f()</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123; <span class="comment">// 初始化成功才将标记置为已初始化。</span></span><br><span class="line">            atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 但以上只是保证 `Once` 可放心地被重试，需要自行检查资源是否已被初始化：</span></span><br><span class="line"><span class="keyword">type</span> AnimalStore <span class="keyword">struct</span> &#123;</span><br><span class="line">    once   sync.Once</span><br><span class="line">    inited <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AnimalStore)</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line">    a.once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        longOperationSetupDbOpenFilesQueuesEtc()</span><br><span class="line">        atomic.StoreUint32(&amp;a.inited, <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AnimalStore)</span> <span class="title">CountOfCats</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.LoadUint32(&amp;a.inited) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, NotYetInitedError</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在标准库的 <code>Once</code> 上扩展，可以：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Once</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Done</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> atomic.LoadUint32((*<span class="keyword">uint32</span>)(unsafe.Pointer(&amp;o.Once))) == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> flag Once</span><br><span class="line">    fmt.Println(flag.Done())</span><br><span class="line"></span><br><span class="line">    flag.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    fmt.Println(flag.Done())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外 Go 没有提供 Immutable 类型，任何全局变量都可以修改。以全局变量形式实现的单例容易带来安全问题，因此需要控制好其作用域：比如不暴露变量本身（包内），而只对外提供 <code>GetXxx</code> 方法。</p>
<h2 id="Pool-池"><a href="#Pool-池" class="headerlink" title="Pool 池"></a>Pool 池</h2><p>Go 采用 <a target="_blank" rel="noopener" href="https://blog.golang.org/ismmkeynote">三色并发标记算法</a> 实现自动标记对象和回收，但在垃圾收集阶段还是会有 STW 时间。为了减少对象创建回收开销可使用对象池。</p>
<p><code>Pool</code> 用于保存一组可独立访问的临时（即当失去引用时会被回收）对象，其本身是线程安全的，但于其它并发原语一样不能复用。其提供以下方法：</p>
<ul>
<li><p>  <code>New</code>：创建对象，当调用 <code>Get</code> 但池中没有空闲元素时，即调用 <code>New</code>；如果没有设置 <code>New</code>，则调用 <code>Get</code> 时返回 nil。</p>
</li>
<li><p>  <code>Get</code>：从池中取走一个对象，可能是 nil（没有设置 <code>New</code> 或没有空闲对象返回）。</p>
</li>
<li><p>  <code>Put</code>：归还一个对象给池以供复用，如果传入 nil 会被忽略。</p>
</li>
</ul>
<blockquote>
<p>  常见的使用场景是连接池：比如标准库提供的 <code>Client</code>、数据库连接池 <code>DB</code>、第三方库 <a target="_blank" rel="noopener" href="https://github.com/fatih/pool">fatih/pool</a>（不局限于 TCP 连接）等（但由于 <code>Pool</code> 无通知地回收对象，连接池不建议基于 <code>Pool</code> 实现）。</p>
</blockquote>
<h3 id="实现细节-5"><a href="#实现细节-5" class="headerlink" title="实现细节"></a>实现细节</h3><p><code>Pool</code> 内部字段 <code>local</code> 和 <code>victim</code> 用于存储空闲元素，每次垃圾回收时，<code>Pool</code> 会把 <code>victim</code> 的对象移除，把 <code>local</code> 的数据移给 <code>victim</code>。因此 <code>local</code> 被清空，而 <code>victim</code> 存放临时对象：可在 GC 时被移除，或通过 <code>Get</code> 重用。</p>
<p>其中 GC 时 <code>Poll</code> 的处理逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolCleanup</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 丢弃当前 victim，此时 STW（所以不用加锁）。</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> oldPools &#123;</span><br><span class="line">        p.victim = <span class="literal">nil</span></span><br><span class="line">        p.victimSize = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 local 复制给 victim, 并将原 local 置为 nil。</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allPools &#123;</span><br><span class="line">        p.victim = p.local</span><br><span class="line">        p.victimSize = p.localSize</span><br><span class="line">        p.local = <span class="literal">nil</span></span><br><span class="line">        p.localSize = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    oldPools, allPools = allPools, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>local</code> 包含 <code>poolLocalInternal</code> 字段并提供 CPU 缓存对齐，从而避免 false sharing。其中 <code>poolLocalInternal</code>：</p>
<ul>
<li><p>  <code>private</code>：表示只能由一个 P 存取的缓存元素。一个 P 同时只能执行一个 goroutine，所以不会有并发的问题。</p>
</li>
<li><p>  <code>shared</code>：可以由任意的 P 访问，但是只有本地的 P 才能 pushHead/popHead，其它 P 可以 popTail，相当于只有一个本地的 P 作为生产者，多个 P 作为消费者（使用 local-free 的 queue 列表实现）。</p>
</li>
</ul>
<p><code>Get</code>：按以下优先级取对象：本地 <code>private</code> -&gt; 本地 <code>shared</code> -&gt; <code>getSlow</code>（其它的 <code>shared</code>）-&gt; <code>New</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="comment">// 把当前 goroutine 固定在当前的 P上</span></span><br><span class="line">    l, pid := p.pin()</span><br><span class="line">    x := l.private <span class="comment">// 优先从 local 的 private 取。</span></span><br><span class="line">    l.private = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 从 local.shared 取（从 head 读取并移除）</span></span><br><span class="line">        x, _ = l.shared.popHead()</span><br><span class="line">        <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">            x = p.getSlow(pid) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    runtime_procUnpin()</span><br><span class="line">    <span class="comment">// 如果没有获取到，尝试使用New函数生成一个新的</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;</span><br><span class="line">        x = p.New()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">getSlow</span><span class="params">(pid <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    size := atomic.LoadUintptr(&amp;p.localSize)</span><br><span class="line">    locals := p.local                       </span><br><span class="line">    <span class="comment">// 从其它 proc 中尝试偷取一个元素</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(size); i++ &#123;</span><br><span class="line">        l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="keyword">int</span>(size))</span><br><span class="line">        <span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果其它 proc 也没有可用元素，尝试从 vintim 中获取。</span></span><br><span class="line">    size = atomic.LoadUintptr(&amp;p.victimSize)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &gt;= size &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    locals = p.victim</span><br><span class="line">    l := indexLocal(locals, pid)</span><br><span class="line">    <span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123; <span class="comment">// 先从 vintim 中的 local private 获取。</span></span><br><span class="line">        l.private = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(size); i++ &#123; <span class="comment">// 从 vintim 其它 proc 尝试偷取。</span></span><br><span class="line">        l := indexLocal(locals, (pid+i)%<span class="keyword">int</span>(size))</span><br><span class="line">        <span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 victim 中都没有，则把 victim 标记为空，快速跳过后续查找。</span></span><br><span class="line">    atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Put</code>：设置本地 <code>private</code>，如已经有值就把此元素 push 到本地队列中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 直接抛弃 nil。</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123; </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    l, _ := p.pin()</span><br><span class="line">    <span class="comment">// 如果本地 private 没有值，直接设置。</span></span><br><span class="line">    <span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123; </span><br><span class="line">        l.private = x</span><br><span class="line">        x = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则加入到本地队列中。</span></span><br><span class="line">    <span class="keyword">if</span> x != <span class="literal">nil</span> &#123; </span><br><span class="line">        l.shared.pushHead(x)</span><br><span class="line">    &#125;</span><br><span class="line">    runtime_procUnpin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用须知-5"><a href="#使用须知-5" class="headerlink" title="使用须知"></a>使用须知</h3><p><strong>内存泄漏</strong>：比如下面的 buffer 池，在取出 bytes.Buffer 使用时可以无限制地往里面插入大量 byte。此时即使 Reset 再放回到池中 byte slice 容量也不会改变，所占空间依然很大；由于 Pool 回收机制，大的 Buffer 可能不被回收。因此使用 <code>Pool</code> 回收 buffer 时，要检查回收对象大小，如果 buffer 太大就不要回收，否则太浪费。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffers = sync.Pool&#123;</span><br><span class="line">    New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetBuffer</span><span class="params">()</span> *<span class="title">bytes</span>.<span class="title">Buffer</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> buffers.Get().(*bytes.Buffer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PutBuffer</span><span class="params">(buf *bytes.Buffer)</span></span> &#123;</span><br><span class="line">    buf.Reset()</span><br><span class="line">    buffers.Put(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内存浪费</strong>：即当池中 buffer 比较大，但实际上只用到较小的部分。可以根据对象大小把池分为几层，根据需要在指定的池中存取。比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    bufioReaderPool sync.Pool</span><br><span class="line">    bufioWriter2kPool sync.Pool</span><br><span class="line">    bufioWriter4kPool sync.Pool</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> copyBufPool = sync.Pool&#123;</span><br><span class="line">    New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">32</span>*<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">return</span> &amp;b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bufioWriterPool</span><span class="params">(size <span class="keyword">int</span>)</span> *<span class="title">sync</span>.<span class="title">Pool</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> size &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> &lt;&lt; <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;bufioWriter2kPool</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span> &lt;&lt; <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;bufioWriter4kPool    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一些第三方库中也有这种 <code>Pool</code> 的实现：</p>
<ul>
<li><p>  <a target="_blank" rel="noopener" href="https://github.com/vitessio/vitess/blob/main/go/bucketpool/bucketpool.go">Vitess</a> 的 Bucketpool</p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://github.com/valyala/bytebufferpool">valyala/bytebufferpool</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://github.com/oxtoacart/bpool">oxtoacart/bpool</a></p>
</li>
</ul>
<h3 id="Worker-Pool"><a href="#Worker-Pool" class="headerlink" title="Worker Pool"></a>Worker Pool</h3><p>尽管 goroutine 很轻量级（栈 2048bytes，最大可扩展到 1GB），但大量的 goroutine 在调度和垃圾回收时的开销也会很大。因此可以创建 Worker Pool 减少 goroutine 的使用。比如用固定数量的 goroutine 处理大量连接请求：<a target="_blank" rel="noopener" href="https://github.com/valyala/fasthttp/blob/9f11af296864153ee45341d3f2fe0f5178fd6210/workerpool.go#L16">fasthttp</a>。</p>
<p>大部分 Worker Pool 是通过 Channel 来缓存任务（能方便地实现并发保护），有的是多个 Worker 共享同一个任务 Channel，有的是每个 Worker 都有独立的 Channel。</p>
<p>推荐的第三方库：</p>
<ul>
<li><p>  <a target="_blank" rel="noopener" href="https://godoc.org/github.com/gammazero/workerpool">gammazero/workerpool</a>：可无限制地提交任务，有更便利的 Submit 和 SubmitWait 方法提交任务，还可以提供当前 Worker 数和任务数以及关闭 Pool 的功能。</p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://godoc.org/github.com/ivpusic/grpool">ivpusic/grpool</a>：创建 Pool 时需要提供 Worker 的数量和等待执行的任务的最大数量，可直接往 Channel 放入任务。</p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://godoc.org/github.com/dpaks/goworkers">dpaks/goworkers</a>：提供了更便利的 Submit 方法提交任务以及 Worker 数、任务数等查询方法、关闭 Pool 的方法。执行结果需要在 ResultChan 和 ErrChan 中去获取，没有提供阻塞方法，但可以在初始化时设置 Worker 数量和任务数。</p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://github.com/panjf2000/ants">panjf2000/ants</a>、<a target="_blank" rel="noopener" href="https://github.com/Jeffail/tunny">Jeffail/tunny</a>、<a target="_blank" rel="noopener" href="https://github.com/benmanns/goworker">benmanns/goworker</a>、<a target="_blank" rel="noopener" href="https://github.com/go-playground/pool">go-playground/pool</a>、<a target="_blank" rel="noopener" href="https://github.com/Sherifabdlnaby/gpool">Sherifabdlnaby/gpool</a>、<a target="_blank" rel="noopener" href="https://github.com/alitto/pond">alitto/pond</a> 等。</p>
</li>
</ul>
<h2 id="Context-上下文"><a href="#Context-上下文" class="headerlink" title="Context 上下文"></a>Context 上下文</h2><p>上下文即在 API 或方法调用之间，传递的除了业务参数外的信息（比如 HTTP 请求的附带信息），Go 标准库提供的 <code>Context</code> 甚至还提供了超时和取消机制。</p>
<blockquote>
<p>  在 Go 服务中，传入的请求通过创建 goroutine 去处理，在此 goroutine 中通常需要派生出额外的 goroutine 来访问其他后端，比如同时访问数据库和 RPC 服务。</p>
<p>  这些 goroutine 通常需要访问特定于请求的值（如用户身份相关信息），而且当请求被取消或超时，处理该请求的所有 goroutine 都应该快速退出（fail fast），使系统回收其正在使用的资源。</p>
</blockquote>
<p><code>Context</code> 包括以下方法：</p>
<ul>
<li><p>  <code>Deadline</code>：返回该 <code>Context</code> 被取消的截止日期。如果没有设置则 ok 的值是 false。每次调用都是返回相同结果。</p>
</li>
<li><p>  <code>Done</code>：返回 <code>Channel</code> 对象，在 <code>Context</code> 被取消时此 <code>Channel</code> 会被 close，可能会返回 nil。cancel、timeout、deadline 都可能导致 <code>Done</code> 被 close，每次调用都是返回相同结果。</p>
</li>
<li><p>  <code>Err</code>：当 <code>Done</code> 被 close 时可以通过 <code>Err</code> 获取错误信息，否则返回 nil。</p>
</li>
<li><p>  <code>Value</code>：返回此 <code>Context</code>中和指定 key 关联的 value。</p>
</li>
</ul>
<blockquote>
<p>  CancelFunc 调用 WithXxx 后返回的函数句柄，用于主动让下游结束。而 Done 则是被上游通知结束。</p>
</blockquote>
<p>生成顶层 <code>Context</code> 的方法（底层一样）：</p>
<ul>
<li><p>  <code>Background</code>：返回非 nil 的、空的 <code>Context</code>。没有值、不会被 cancel、不会超时、没有截止日期。一般用于主函数、初始化、测试以及创建根 <code>Context</code>。</p>
</li>
<li><p>  <code>TODO</code>：返回非 nil 的、空的 <code>Context</code>。没有值、不会被 cancel、不会超时、没有截止日期。一般用于不清楚是否该用 Context，或者目前还不知道要传递什么上下文信息时。</p>
</li>
</ul>
<p>使用时遵循规则：</p>
<ul>
<li>  一般函数使用 <code>Context</code> 时会把它放在第一个参数的位置。</li>
<li>  不要把 nil 用做 <code>Context</code> 类型的参数值（可以使用 <code>context.Background()</code>）。</li>
<li>  <code>Context</code> 只用来临时做函数之间的上下文透传，不能持久化（数据库、本地文件、全局变量、缓存）。</li>
<li>  常使用 <code>struct&#123;&#125;</code> 定义 key 的类型。对于 exported key 的静态类型，常是接口或指针。目的是尽量减少内存分配。</li>
</ul>
<h3 id="特殊-Context"><a href="#特殊-Context" class="headerlink" title="特殊 Context"></a>特殊 Context</h3><p><code>WithXxx</code> 函数的功能是为父节点生成带有 <code>Done</code> 方法的子节点，并返回子节点的 <code>CancelFunc</code> 函数句柄。</p>
<h4 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h4><p>基于 parent <code>Context</code> 生成新的 <code>Context</code>，其保存了一个 key-value 键值对，用来传递上下文。它覆盖了 <code>Value</code> 方法，优先从自己的存储中检查 key，不存在则从 parent 中继续检查。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">context</span>] &lt;---+ c.Context.Value(<span class="built_in">key</span>)</span><br><span class="line">              |</span><br><span class="line">           [<span class="built_in">context</span>] &lt;---+</span><br><span class="line">                         |</span><br><span class="line">           [G] -----&gt; [<span class="built_in">context</span>]</span><br><span class="line">           <span class="built_in">context</span>.Value(<span class="built_in">key</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line">    key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c* valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">        <span class="keyword">return</span> c.val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>支持链式查找。查找不存在还会向 parent <code>Context</code> 查找，如果 parent 还是 valueCtx 则遵循相同原则。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ctx = context.TODO()</span><br><span class="line">ctx = context.WithValue(ctx, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;0001&quot;</span>)</span><br><span class="line">ctx = context.WithValue(ctx, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;0001&quot;</span>)</span><br><span class="line">ctx = context.WithValue(ctx, <span class="string">&quot;key3&quot;</span>, <span class="string">&quot;0001&quot;</span>)</span><br><span class="line">ctx = context.WithValue(ctx, <span class="string">&quot;key4&quot;</span>, <span class="string">&quot;0004&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(ctx.Value(<span class="string">&quot;key1&quot;</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  key 不应该是 string 或其它内建类型，否则在包之间使用 Context 时容易产生冲突（如果能保证 key 不会冲突，则可以使用自定义类型或内建类型）。</p>
</blockquote>
<h4 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h4><p>方法返回 parent 的副本，副本中的 <code>Done Channel</code> 是新建对象，类型是 cancelCtx。常在需要主动取消长时间的任务时使用：创建 <code>Context</code>，把它传给长时间执行任务的 goroutine。需要中止任务时就可以 cancel 这个 <code>Context</code>，长时间执行任务的 goroutine 就可以通过检查它，知道 <code>Context</code> 已经被取消。</p>
<p><code>WithCancel </code> 返回的第二个值是一个 cancel 函数。只要任务正常完成就需要调用 cancel，这个 <code>Context</code> 才能释放资源（通知 children 处理 cancel，从它的 parent 中把自己移除，释放相关的 goroutine）。</p>
<p>其内部实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">    propagateCancel(parent, &amp;c)<span class="comment">// 把 c 向上传播</span></span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newCancelCtx 返回初始化的 cancelCtx.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span> <span class="title">cancelCtx</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cancelCtx 被取消时，<code>Err</code> 就是这个 Canceled 错误：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> Canceled = errors.<span class="literal">New</span>(<span class="string">&quot;context canceled&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="WithTimeout"><a href="#WithTimeout" class="headerlink" title="WithTimeout"></a>WithTimeout</h4><p>和 <code>WithDeadline</code> 一样，其参数是超时时间。超时时间加上当前时间即截止时间，<code>WithTimeout</code> 的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 当前时间 + timeout 就是 deadline</span></span><br><span class="line">    <span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WithDeadline"><a href="#WithDeadline" class="headerlink" title="WithDeadline"></a>WithDeadline</h4><p><code>WithDeadline</code> 返回一个 parent 的副本，并设置不晚于参数 d 的截止时间，类型为 timerCtx 或 cancelCtx。如果其截止时间晚于 parent 的截止时间，就以 parent 的截止时间为准，并返回一个类型为 cancelCtx 的 Context（parent 的截止时间到了就会取消这个 cancelCtx）。</p>
<p>如果当前时间已经超过了截止时间就直接返回一个已经被 cancel 的 timerCtx；否则启动一个定时器，到截止时间取消这个 timerCtx。</p>
<p>因此触发 timerCtx 的 <code>Done</code> 被 close：</p>
<ul>
<li><p>  截止时间到。</p>
</li>
<li><p>  cancel 函数被调用。</p>
</li>
<li><p>  parent 的 <code>Done</code> 被 close。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果 parent 截止时间更早，返回一个 cancelCtx 即可</span></span><br><span class="line">    <span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">        <span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">    &#125;</span><br><span class="line">    c := &amp;timerCtx&#123;</span><br><span class="line">        cancelCtx: newCancelCtx(parent),</span><br><span class="line">        deadline:  d,</span><br><span class="line">    &#125;</span><br><span class="line">    propagateCancel(parent, c) <span class="comment">// 同 cancelCtx 的处理逻辑</span></span><br><span class="line">    dur := time.Until(d)</span><br><span class="line">    <span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123; <span class="comment">// 当前时间已超过了截止时间，直接 cancel</span></span><br><span class="line">        c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">        <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 设置定时器到截止时间后取消</span></span><br><span class="line">        c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slowOperationWithTimeout</span><span class="params">(ctx context.Context)</span> <span class="params">(Result, error)</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithTimeout(ctx, <span class="number">100</span>*time.Millisecond)</span><br><span class="line">    <span class="keyword">defer</span> cancel() <span class="comment">// 一旦 slowOperation 完成就调用 cancel</span></span><br><span class="line">    <span class="keyword">return</span> slowOperation(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="管理-goroutine-生命周期"><a href="#管理-goroutine-生命周期" class="headerlink" title="管理 goroutine 生命周期"></a>管理 goroutine 生命周期</h3><p>把 Context 传递给 goroutine，由 goroutine 检查 Context 的 <code>Done</code> 是否关闭：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;goroutine exit&quot;</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    cancel()</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用须知-6"><a href="#使用须知-6" class="headerlink" title="使用须知"></a>使用须知</h3><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p><code>context.WithValue</code> 每次调用都会创建新的对象，以链表关联。这种结构是线程安全，支持并发访问，但由于访问效率较低，并不适合大量地调用（可以传递 map 或 struct）。</p>
<p>传递的数据是面向请求，适用于链路追踪、多租户染色发布等。不应该作为函数的可选参数来使用（比如 <code>Context</code> 中存放 <code>sql.Tx</code> 对象传递到 data 层使用等），因为元数据是隐式、面向请求的旁路信息挂载，而函数参数是显式、用于处理业务流程的。</p>
<p>同一个 <code>Context</code> 对象可以传递给在不同 goroutine 中运行的函数，对于多个 goroutine 同时使用是安全的。其中 value 应该是 immutable 的，即 <code>context.WithValue(ctx, oldvalue)</code>。如果携带了集合类型的数据，要注意到读写操作可能造成 data race，可以用 COW（Copy on Write）的思路解决。</p>
<h4 id="级联取消"><a href="#级联取消" class="headerlink" title="级联取消"></a>级联取消</h4><p>当一个 <code>Context</code> 被取消时，从它派生的所有 <code>Context</code> 也将被取消。<code>WithCancel(ctx)</code> 参数 ctx 认为是 parent ctx，在内部会进行传播关系链的关联。调用 <code>Done()</code> 会返回一个 chan，当取消某个 parent context，实际上会递归层层 cancel 关闭自己 child context 的 done chan，从而让整个调用链中所有监听 cancel 的 goroutine 退出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">gen := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dst := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> dst &lt;- n:</span><br><span class="line">                    n++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) &#123;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="超时调用"><a href="#超时调用" class="headerlink" title="超时调用"></a>超时调用</h4><p>利用 parent/child 机制，只需要启动一个定时器，每当超时直接将当前的 <code>Context</code> cancel，就可以使监听在当前和下层的 <code>context.Done()</code> 的 goroutine 退出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shortDuration = <span class="number">1</span> * time.Millisecond</span><br><span class="line"></span><br><span class="line">d := time.Now().Add(shortDuration)</span><br><span class="line">ctx, cancel := context.WithDeadline(context.Background(), d)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// 超时未完成</span></span><br><span class="line">    <span class="keyword">case</span> &lt;- time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">    	fmt.Println(<span class="string">&quot;overslept&quot;</span>)</span><br><span class="line">    <span class="comment">// 完成</span></span><br><span class="line">    <span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">        fmt.Println(ctx.Err())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为 <code>Context</code> 设计带超时的服务调用，并不意味着会通知远程服务就会自动取消这次调用，一般只是避免客户端长时间等待，服务端依然还在处理请求。所以有时 <code>Context</code> 并不会减少对服务端的请求负担。</p>
<p>如果在 <code>Context</code> 被 cancel 时能关闭和服务端的连接、中断和数据库的通讯、停止对本地文件的读写（依赖于超时的底层处理机制），这样才能减少服务调用的压力。</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>将 <code>Context</code> 集成到 API 中时，需要注意其作用域是请求级别的。比如贯穿请求处理过程，但于数据模型存在则没有意义，因此不应该将其存储在结构体中或持久化。但有例外是该结构纯粹用作通过通道传递的消息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> message <span class="keyword">struct</span> &#123;</span><br><span class="line">    responseChan <span class="keyword">chan</span>&lt;- <span class="keyword">int</span></span><br><span class="line">    parameter <span class="keyword">string</span></span><br><span class="line">    ctx context.Context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可用以下方法在 API 中集成 <code>Context</code> 对象：</p>
<ul>
<li><p>  首参数传递 <code>Context</code> 对象，参考 net 包 <code>func (d *Dialer) DialContext(ctx context.Context, network, address string) (Conn, error)</code>。可通过 context 对象取消函数调用。</p>
</li>
<li><p>  在第一个 <code>Request</code> 对象中携带可选的 <code>Context</code> 对象。例如 net/http 包的 <code>func (r *Request) WithContext(ctx context.Context) *Request</code>，通过携带给定的 <code>Context</code> 对象返回一个新的 <code>Request</code> 对象。</p>
</li>
</ul>
<h2 id="Atomic-原子操作"><a href="#Atomic-原子操作" class="headerlink" title="Atomic 原子操作"></a>Atomic 原子操作</h2><p>原子操作即由 CPU 提供基础支持、确保指令必然完全执行/不执行的操作。即使在多处理器、多核、有 CPU cache（多 goroutine 访问），该操作也能保证原子性。</p>
<p>Go 标准库 <code>sync/atomic</code> 为 int32、int64、uint32、uint64、uintptr、Pointer 等类型提供了原子操作方法：AddXXX、CompareAndSwapXXX、SwapXXX、LoadXXX、StoreXXX 等，其操作对象是 <strong>变量的地址</strong>。</p>
<p><code>Add</code>：加法运算的第一个参数 delta 可以是负数，相当于减法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt32</span><span class="params">(addr *<span class="keyword">int32</span>, delta <span class="keyword">int32</span>)</span> <span class="params">(<span class="built_in">new</span> <span class="keyword">int32</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>对于无符号整型，可以利用补码规则：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AddUint32(&amp;x, ^<span class="keyword">uint32</span>(c<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line">AddUint32(&amp;x, ^<span class="keyword">uint32</span>(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p><code>CAS</code>：比较替换，只有 addr 的值为 old，才把它修改为 new 并返回 true，否则返回 false（同理还有 <code>Swap</code>，区别是直接替换、不比较）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt32</span><span class="params">(addr *<span class="keyword">int32</span>, <span class="built_in">new</span> <span class="keyword">int32</span>)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure>

<p><code>Load</code> 和 <code>Store</code>：取出 addr 地址中的值，以及把一个值存入到指定的 addr 地址中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt32</span><span class="params">(addr *<span class="keyword">int32</span>)</span> <span class="params">(val <span class="keyword">int32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt32</span><span class="params">(addr *<span class="keyword">int32</span>, val <span class="keyword">int32</span>)</span></span></span><br></pre></td></tr></table></figure>

<p><code>Value</code>：支持原子地存取对象类型（不能 <code>CAS</code> 和 <code>Swap</code>），常用于配置变更等场景中。</p>
<p>参考以下实现配置变更的例子：</p>
<ul>
<li><p>  定义 <code>Value</code> 类型的变量 <code>config</code>， 用于存储配置信息。</p>
</li>
<li><p>  启动一个 goroutine，让它随机 sleep 一段时间，之后变更配置，并通过 <code>Cond</code> 通知其它 reader 加载新配置。</p>
</li>
<li><p>  启动一个 goroutine 等待配置变更的信号，一旦有变更就会加载最新的配置。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    NodeName <span class="keyword">string</span></span><br><span class="line">    Addr     <span class="keyword">string</span></span><br><span class="line">    Count    <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadNewConfig</span><span class="params">()</span> <span class="title">Config</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Config&#123;</span><br><span class="line">        NodeName: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">        Addr:     <span class="string">&quot;10.77.95.27&quot;</span>,</span><br><span class="line">        Count:    rand.Int31(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> config atomic.Value</span><br><span class="line">    config.Store(loadNewConfig())</span><br><span class="line">    <span class="keyword">var</span> cond = sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新 config</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            time.Sleep(time.Duration(<span class="number">5</span>+rand.Int63n(<span class="number">5</span>)) * time.Second)</span><br><span class="line">            config.Store(loadNewConfig())</span><br><span class="line">            cond.Broadcast() <span class="comment">// 通知等待着配置已变更</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            cond.L.Lock()</span><br><span class="line">            cond.Wait()                 <span class="comment">// 等待变更信号</span></span><br><span class="line">            c := config.Load().(Config) <span class="comment">// 读取新的配置</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;new config: %+v\n&quot;</span>, c)</span><br><span class="line">            cond.L.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  在操作系统中，write 的地址基本上是对齐的（aligned）。 比如 32 位操作系统、CPU 和编译器，write 的地址总是 4 的倍数，64 位系统则总是 8 的倍数。这种情况下通过一个指令就可以实现地址的写操作，不会导致其他线程看到部分写。如果地址不是对齐，处理器需要分成两个指令处理，如果只执行了一个指令便被其它线程看到，被称为 撕裂写（torn write） 。因此赋值操作必须是原子操作，才能保证数据完整。</p>
<p>  对于多核处理器，某个核对地址的值的更改在更新到主内存中前，是在多级缓存中存放的，此时其它核看到的数据可能不一样。由于 cache、指令重排，可见性等问题的存在，实现原子性依赖于内存屏障（memory fence）：写内存屏障告知处理器，必须等到其管道中未完成的写被刷新到内存中再进行操作。此操作会让其它处理器的缓存失效，以便使之从主内存中获取最新值。</p>
</blockquote>
<p>atomic 包方法会提供内存屏障功能，所以可以保证赋值的完整性，还能保证可见性：某个核更新了某地址的值，其它处理器总是能读取到它的最新值。需要注意的是，处理器之间保证数据的一致性也是会降低性能的。</p>
<h3 id="功能扩展"><a href="#功能扩展" class="headerlink" title="功能扩展"></a>功能扩展</h3><p>一些第三方库对标准库的原子操作 API 提供了进一步封装。比如 <a target="_blank" rel="noopener" href="https://github.com/uber-go/atomic">uber-go/atomic</a> 定义和封装了几种与常见类型对应的原子操作类型：Bool、Duration、Error、Float64、Int32、Int64、String、Uint32、Uint64 等。以及原子操作方法：CAS、Store、Swap、Toggle 等。其使用也更友好：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> running atomic.Bool</span><br><span class="line">running.Store(<span class="literal">true</span>)</span><br><span class="line">running.Toggle()</span><br><span class="line">fmt.Println(running.Load()) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="扩展：实现无锁队列"><a href="#扩展：实现无锁队列" class="headerlink" title="扩展：实现无锁队列"></a>扩展：实现无锁队列</h3><p>原子操作常用来实现 Lock-Free 数据结构，相比起同步的数据结构往往有更高的性能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LKQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    head unsafe.Pointer</span><br><span class="line">    tail unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过链表实现，这个数据结构代表链表中的节点</span></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    next  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLKQueue</span><span class="params">()</span> *<span class="title">LKQueue</span></span> &#123;</span><br><span class="line">    n := unsafe.Pointer(&amp;node&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> &amp;LKQueue&#123;head: n, tail: n&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *LKQueue)</span> <span class="title">Add</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    n := &amp;node&#123;value: v&#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        tail := load(&amp;q.tail)</span><br><span class="line">        next := load(&amp;tail.next)</span><br><span class="line">        <span class="keyword">if</span> tail == load(&amp;q.tail) &#123;</span><br><span class="line">            <span class="keyword">if</span> next == <span class="literal">nil</span> &#123;                     <span class="comment">// 还没有新数据入队</span></span><br><span class="line">                <span class="keyword">if</span> cas(&amp;tail.next, next, n) &#123;    <span class="comment">// 增加到队尾</span></span><br><span class="line">                    cas(&amp;q.tail, tail, n)        <span class="comment">// 入队成功，移动尾巴指针</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                             <span class="comment">// 已有新数据加到队列后面，需要移动尾指针</span></span><br><span class="line">                cas(&amp;q.tail, tail, next)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *LKQueue)</span> <span class="title">Poll</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        head := load(&amp;q.head)</span><br><span class="line">        tail := load(&amp;q.tail)</span><br><span class="line">        next := load(&amp;head.next)</span><br><span class="line">        <span class="keyword">if</span> head == load(&amp;q.head) &#123;</span><br><span class="line">            <span class="keyword">if</span> head == tail &#123;                        <span class="comment">// head 和 tail一样</span></span><br><span class="line">                <span class="keyword">if</span> next == <span class="literal">nil</span> &#123;                     <span class="comment">// 空队列</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">                &#125;</span><br><span class="line">                                                     <span class="comment">// 只是尾指针还未调整，尝试调整它指向下一个。</span></span><br><span class="line">                cas(&amp;q.tail, tail, next)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                     <span class="comment">// 读取出队的数据，头指针移动到下一个。</span></span><br><span class="line">                v := next.value</span><br><span class="line">                <span class="keyword">if</span> cas(&amp;q.head, head, next) &#123;</span><br><span class="line">                    <span class="keyword">return</span> v</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(p *unsafe.Pointer)</span> <span class="params">(n *node)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将 unsafe.Pointer 原子加载转换成 node</span></span><br><span class="line">    <span class="keyword">return</span> (*node)(atomic.LoadPointer(p))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cas</span><span class="params">(p *unsafe.Pointer, old, <span class="built_in">new</span> *node)</span> <span class="params">(ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 封装 CAS，避免直接将 *node 转换成 unsafe.Pointer</span></span><br><span class="line">    <span class="keyword">return</span> atomic.CompareAndSwapPointer(p, unsafe.Pointer(old), unsafe.Pointer(<span class="built_in">new</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h2><p>信号量表示为使用一个（范围 [0, n] 的）变量实现并发控制的能力。当 goroutine 完成对此信号量等待（wait）时该计数值就减 1，对此信号量释放（release）时，该计数值就加 1。只有当计数器大于 0，等待的 goroutine 才有可能成功返回。</p>
<blockquote>
<p>  更复杂的信号量可以使用抽象数据类型代替变量，用来代表复杂的资源类型。</p>
</blockquote>
<h3 id="P-V-操作"><a href="#P-V-操作" class="headerlink" title="P/V 操作"></a>P/V 操作</h3><p>信号量支持以下操作：</p>
<ul>
<li><p>  初始化：设定初始的资源数量。</p>
</li>
<li><p>  P：信号量计数值 -1，如果新值为负，则调用者被阻塞并加入到等待队列中。否则调用者继续执行，并获得一个资源。</p>
</li>
<li><p>  V：信号量计数值 +1，如果先前计数值为负，表示当前有等待的 P 操作调用者，则会从等待队列中取出一个等待的调用者唤醒，使之继续执行。</p>
</li>
</ul>
<p>信号量可分为 <strong>计数信号量</strong>（counting semaphre）和 <strong>二进位信号量</strong>（binary semaphore）。计数信号量的计数值可以是任意整数，在特殊的情况下只为 0 或 1，则为二进位信号量，可提供互斥功能。</p>
<p>因此有时互斥锁也会使用二进位信号量实现（常用于保护一组资源，比如数据库连接池、客户端连接等），此时 P/V 操作相当于互斥锁的 Lock/Unlock。</p>
<blockquote>
<p>  在 Windows 中，互斥锁只能由持有锁的线程释放。而二进位信号量则没有这个限制。但对于 Go 而言，互斥锁也可以由非持锁 goroutine 释放，所以在行为上没有严格区别。</p>
</blockquote>
<h3 id="标准库实现"><a href="#标准库实现" class="headerlink" title="标准库实现"></a>标准库实现</h3><p>Go 标准库提供的 <code>Mutex</code> 内部使用信号量控制 goroutine 的等待和唤醒，并实现 P/V 操作的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="keyword">int32</span></span><br><span class="line">    sema  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_Semacquire</span><span class="params">(s *<span class="keyword">uint32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_SemacquireMutex</span><span class="params">(s *<span class="keyword">uint32</span>, lifo <span class="keyword">bool</span>, skipframes <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_Semrelease</span><span class="params">(s *<span class="keyword">uint32</span>, handoff <span class="keyword">bool</span>, skipframes <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>但只作内部使用，没有封装对外暴露。要使用信号量可以用扩展包 <a target="_blank" rel="noopener" href="https://pkg.go.dev/golang.org/x/sync/semaphore">semaphore</a> 提供的 <code>Weighted</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weighted <span class="keyword">struct</span> &#123;</span><br><span class="line">    size    <span class="keyword">int64</span>         <span class="comment">// 最大资源数</span></span><br><span class="line">    cur     <span class="keyword">int64</span>         <span class="comment">// 当前已被使用的资源</span></span><br><span class="line">    mu      sync.Mutex    <span class="comment">// 互斥锁，对字段的保护</span></span><br><span class="line">    waiters list.List     <span class="comment">// 等待队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供以下方法：</p>
<ul>
<li><p>  <code>Acquire</code>：相当于 P 操作，可一次获取多个资源，如果没有足够多的资源调用者就会被阻塞。第一个参数是 <code>Context</code>，用于增加超时或 cancel 机制。如果正常获取资源就返回 nil；否则返回 <code>ctx.Err()</code> 且信号量不改变。其内部实现需要监控资源是否可用，以及检测 Context 的 Done 是否已关闭。</p>
</li>
<li><p>  <code>Release</code>：相当于 V 操作，可将 n 个资源释放、返还给信号量。如果调用该方法时，传递比请求到的数量更大的数值就会 panic。</p>
</li>
<li><p>  <code>TryAcquire</code>：尝试不阻塞地获取 n 个资源，要么成功获取 n 个资源返回 true，要么获取失败返回 false。</p>
</li>
</ul>
<p>其中 <code>Acquire</code> 和 <code>Release</code> 的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">Acquire</span><span class="params">(ctx context.Context, n <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    s.mu.Lock()</span><br><span class="line">    <span class="comment">// fast path, 如果有足够的资源，都不考虑 ctx.Done 的状态，将 cur 加上 n 就返回。</span></span><br><span class="line">    <span class="keyword">if</span> s.size-s.cur &gt;= n &amp;&amp; s.waiters.Len() == <span class="number">0</span> &#123;</span><br><span class="line">        s.cur += n</span><br><span class="line">        s.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果是不可能完成的任务，请求的资源数大于能提供的最大的资源数</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; s.size &#123;</span><br><span class="line">        s.mu.Unlock()</span><br><span class="line">        <span class="comment">// 依赖 ctx 的状态返回，否则一直等待</span></span><br><span class="line">        &lt;-ctx.Done()</span><br><span class="line">        <span class="keyword">return</span> ctx.Err()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 否则就需要把调用者加入到等待队列中。创建一个 ready chan，以便被通知唤醒。</span></span><br><span class="line">    ready := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    w := waiter&#123;n: n, ready: ready&#125;</span><br><span class="line">    elem := s.waiters.PushBack(w)</span><br><span class="line">    s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// context的Done被关闭</span></span><br><span class="line">          err := ctx.Err()</span><br><span class="line">          s.mu.Lock()</span><br><span class="line">          <span class="keyword">select</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> &lt;-ready: <span class="comment">// 如果被唤醒了，忽略ctx的状态</span></span><br><span class="line">              err = <span class="literal">nil</span></span><br><span class="line">          <span class="keyword">default</span>:     <span class="comment">// 通知 waiter</span></span><br><span class="line">              isFront := s.waiters.Front() == elem</span><br><span class="line">              s.waiters.Remove(elem)</span><br><span class="line">              <span class="comment">// 通知其它的 waiters，检查是否有足够的资源。</span></span><br><span class="line">              <span class="keyword">if</span> isFront &amp;&amp; s.size &gt; s.cur &#123;</span><br><span class="line">                  s.notifyWaiters()</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          s.mu.Unlock()</span><br><span class="line">          <span class="keyword">return</span> err</span><br><span class="line">      <span class="keyword">case</span> &lt;-ready: <span class="comment">// 被唤醒</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">Release</span><span class="params">(n <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    s.mu.Lock()</span><br><span class="line">    s.cur -= n</span><br><span class="line">    <span class="keyword">if</span> s.cur &lt; <span class="number">0</span> &#123;</span><br><span class="line">      s.mu.Unlock()</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;semaphore: released more than held&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    s.notifyWaiters()</span><br><span class="line">    s.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">notifyWaiters</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      next := s.waiters.Front()</span><br><span class="line">      <span class="keyword">if</span> next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// No more waiters blocked.</span></span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      w := next.Value.(waiter)</span><br><span class="line">      <span class="keyword">if</span> s.size-s.cur &lt; w.n &#123;</span><br><span class="line">          <span class="comment">// 避免饥饿，这里还是按照先入先出的方式处理（否则就会优先满足较小的需求，使得大的需求永远不能满足）。</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      s.cur += w.n</span><br><span class="line">      s.waiters.Remove(next)</span><br><span class="line">      <span class="built_in">close</span>(w.ready)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>利用信号量实现 Worker Pool：</p>
<ul>
<li><p>  主 goroutine 是负责任务分发的 dispacher。先请求信号量，获取成功则启动一个 goroutine 处理计算，该 goroutine 会释放信号量（信号量的获取在主 goroutine，释放则在 worker goroutine）；如获取失败就等到有信号量可用时再获取。</p>
</li>
<li><p>  在实际应用中如果想等所有 Worker 执行完，可获取最大计数值的信号量（表示所有申请的都已释放）。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    maxWorkers = runtime.GOMAXPROCS(<span class="number">0</span>)                    <span class="comment">// worker 数量</span></span><br><span class="line">    sema       = semaphore.NewWeighted(<span class="keyword">int64</span>(maxWorkers)) <span class="comment">// 信号量</span></span><br><span class="line">    task       = <span class="built_in">make</span>([]<span class="keyword">int</span>, maxWorkers*<span class="number">4</span>)                <span class="comment">// 任务数</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> task &#123;</span><br><span class="line">        <span class="comment">// 如果无可用 worker 则会阻塞，直到某个 worker 被释放。</span></span><br><span class="line">        _ := sema.Acquire(ctx, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 worker goroutine。</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> sema.Release(<span class="number">1</span>)</span><br><span class="line">            time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            task[i] = i + <span class="number">1</span></span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次请求所有 worker，可确保前面的 worker 都执行完。</span></span><br><span class="line">    <span class="keyword">if</span> err := sema.Acquire(ctx, <span class="keyword">int64</span>(maxWorkers)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;获取所有 worker 失败: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用信号量需要注意，当公平性和安全性损害会导致程序 panic。常见错误：</p>
<ul>
<li><p>  请求资源但没有释放。</p>
</li>
<li><p>  释放从未请求的资源。</p>
</li>
<li><p>  长时间持有资源（即使不需要）。</p>
</li>
<li><p>  不持有资源却直接使用。</p>
</li>
<li><p>  使用不同的信号量控制不同的资源时，也可能导致死锁。</p>
</li>
</ul>
<p>因此必须确保按需请求、按量释放。</p>
<h3 id="使用-Channel-实现"><a href="#使用-Channel-实现" class="headerlink" title="使用 Channel 实现"></a>使用 Channel 实现</h3><p>使用带 buffer 的 Channel 可以实现信号量（其中 P/V 操作以 Lock/Unlock 表示 ，且无法提供一次性申请多个的功能）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> semaphore <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Locker</span><br><span class="line">    ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSemaphore</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">sync</span>.<span class="title">Locker</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> capacity &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        capacity = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;semaphore&#123;ch: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, capacity)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *semaphore)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *semaphore)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &lt;-s.ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于带 buffer 的 Channel 本身就能表示多个资源，更建议直接使用 Channel，除非有必要一次性申请多个。 </p>
<p>除此之外还有第三方库 <a target="_blank" rel="noopener" href="https://github.com/marusama/semaphore">marusama/semaphore</a>，推荐在资源数量不固定、动态变化的场景使用。</p>
<h2 id="SingleFlight-请求合并"><a href="#SingleFlight-请求合并" class="headerlink" title="SingleFlight 请求合并"></a>SingleFlight 请求合并</h2><p>多个 goroutine 同时调用同一个函数时，<code>SingleFlight</code> 可限制只有一个 goroutine 调用，当该 goroutine 返回，再把结果返回给其它 goroutine，可减少并发调用数。</p>
<p>区别于 <code>sync.Once</code> 保证永远只执行一次，<code>SingleFlight</code> 保证多个请求同时调用时只执行一个。前者常用在单次初始化场景，而后者常用于合并并发请求的场景（比如缓存）。尤其当面对类似秒杀等大量并发读时，可有效减缓后端服务压力。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><code>SingleFlight</code> 使用互斥锁 <code>Mutex</code>（提供并发读写保护）和 <code>Map</code>（保存同一个 key 的正在处理请求）实现。其数据结构是 <code>Group</code>，并提供以下方法：</p>
<ul>
<li><p>  <code>Do</code>：执行函数并返回其执行结果。需提供用于确保在同时只有一个请求执行的 key，相同 key 的其它请求会等待该执行请求返回结果。指定 <code>fn</code> 无参函数，返回执行结果或 error。<code>Do</code> 方法返回 <code>fn</code> 执行的结果，以另一个返回值 <code>shared</code> 指示是否返回给多个请求。</p>
</li>
<li><p>  <code>DoChan</code>：类似 <code>Do</code>，区别是返回一个 chan。等 <code>fn</code> 函数执行完，可从该 chan 接收结果。</p>
</li>
<li><p>  <code>Forget</code>：告知 <code>Group</code> 忘记指定 key，之后该 key 请求会执行 <code>fn</code>，而不是等待前一个未完成的 <code>fn</code> 函数返回结果。</p>
</li>
</ul>
<p><code>SingleFlight</code> 内部使用辅助结构 <code>call</code>，代表正在执行、或已完成的 <code>fn</code> 函数请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示一个正在处理或已经处理完的请求。</span></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表示处理完的值，在 waitgroup 完成前只会写一次，在 waitgroup 完成后读取。</span></span><br><span class="line">    val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    err error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指示当 call 在处理时是否要忘掉这个 key。</span></span><br><span class="line">    forgotten <span class="keyword">bool</span></span><br><span class="line">    dups  <span class="keyword">int</span></span><br><span class="line">    chans []<span class="keyword">chan</span>&lt;- Result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示一个 singleflight 对象</span></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.Mutex       <span class="comment">// protects m</span></span><br><span class="line">    m  <span class="keyword">map</span>[<span class="keyword">string</span>]*call <span class="comment">// lazily initialized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Do</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(v <span class="keyword">interface</span>&#123;&#125;, err error, shared <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c, ok := g.m[key]; ok &#123;     <span class="comment">// 如果已存在相同的 key：等待该 key 的第一个请求完成，使用第一个 key 的请求结果返回。</span></span><br><span class="line">        c.dups++</span><br><span class="line">        g.mu.Unlock()</span><br><span class="line">        c.wg.Wait()              </span><br><span class="line">        <span class="keyword">return</span> c.val, c.err, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    c := <span class="built_in">new</span>(call)                 <span class="comment">// 第一个请求，创建一个 call</span></span><br><span class="line">    c.wg.Add(<span class="number">1</span>)</span><br><span class="line">    g.m[key] = c                   <span class="comment">// 加入到 key map 中</span></span><br><span class="line">    g.mu.Unlock()</span><br><span class="line">    g.doCall(c, key, fn)           <span class="comment">// 调用方法</span></span><br><span class="line">    <span class="keyword">return</span> c.val, c.err, c.dups &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">doCall</span><span class="params">(c *call, key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>)</span> &#123;</span><br><span class="line">    c.val, c.err = fn()</span><br><span class="line">    c.wg.Done()</span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    <span class="comment">// 默认情况下 forgotten==false，delete 会被调用。即第一个请求完成后，后续同一个 key 的请求又重新开始 fn 的调用。</span></span><br><span class="line">    <span class="keyword">if</span> !c.forgotten &#123; </span><br><span class="line">        <span class="built_in">delete</span>(g.m, key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> c.chans &#123;</span><br><span class="line">        ch &lt;- Result&#123;c.val, c.err, c.dups &gt; <span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>在 Go 标准库中也用到 <code>SingleFlight</code>：</p>
<ul>
<li><p>  在 net/lookup.go 中，如果同时有查询同一个 host 的请求，<code>lookupGroup</code> 会把请求合并。</p>
</li>
<li><p>  Go 在查询仓库版本信息时，将并发的请求合并成 1 个。</p>
</li>
</ul>
<p><code>SingleFlight</code> 最适合用于解决缓存击穿：并发的请求可以共享同一个结果，避免大量请求不经缓存直接落到数据库上。而且由于是缓存查询，不用考虑幂等性问题。比如缓存框架 groupcache：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;    </span><br><span class="line">    <span class="comment">// loadGroup ensures that each key is only fetched once</span></span><br><span class="line">    <span class="comment">// (either locally or remotely), regardless of the number of</span></span><br><span class="line">    <span class="comment">// concurrent callers.</span></span><br><span class="line">    loadGroup flightGroup</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">load</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, dest Sink)</span> <span class="params">(value ByteView, destPopulated <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">    viewi, err := g.loadGroup.Do(key, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span>  &#123;</span><br><span class="line">      <span class="comment">// 从 cache、peer、local 尝试查询 cache</span></span><br><span class="line">        <span class="keyword">return</span> value, <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        value = viewi.(ByteView)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它项目比如 Cockroachdb、CoreDNS 都有 <code>SingleFlight</code> 的应用。但这一般只用于并发读场景，或是设置单一值的并发写场景。而对于并发的增减写操作则不合适（存在幂等性问题）。</p>
<h2 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier 循环栅栏"></a>CyclicBarrier 循环栅栏</h2><p><code>CyclicBarrier</code> 由第三方库 <a target="_blank" rel="noopener" href="https://github.com/marusama/cyclicbarrier">marusama/cyclicbarrier</a> 提供，类似 <code>WaitGroup</code>，常用于等待多个 goroutine 并发执行，而前者更适用于 <strong>固定数量的 goroutine 等待同一执行点</strong> 的场景，在放行 goroutine 后还能更方便地重复利用（在重用时后者还要处理重置计数值时的并发问题）；后者更适用于 <strong>一个 goroutine 等待一组 goroutine 到达同一执行点</strong> 的场景。</p>
<p>两者对应关系：</p>
<table>
<thead>
<tr>
<th>CyclicBarrier</th>
<th>WaitGroup</th>
</tr>
</thead>
<tbody><tr>
<td>New(n)</td>
<td>var wg WaitGroup(n)<br />wg.Add(n)</td>
</tr>
<tr>
<td>Await</td>
<td>wg.Done<br />wg.Wait<br />wg.Add(b)</td>
</tr>
</tbody></table>
<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p><code>CyclicBarrier</code> 的初始化方法：</p>
<ul>
<li><p>  <code>New</code>：只需要一个参数指定参与者数量。</p>
</li>
<li><p>  <code>NewWithAction</code>：额外提供一个函数，用于在每次到达执行点时执行一次。时间点最后一个参与者到达后、其它参与者未被放行前。可利用它实现放行前的共享状态更新等操作。</p>
</li>
</ul>
<p><code>CyclicBarrier</code> 定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CyclicBarrier <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 等待所有的参与者到达，如果被 ctx.Done() 中断会返回 ErrBrokenBarrier</span></span><br><span class="line">    Await(ctx context.Context) error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置循环栅栏到初始化状态。如果当前有等待者，那么它们会返回ErrBrokenBarrier</span></span><br><span class="line">    Reset()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前等待者的数量</span></span><br><span class="line">    GetNumberWaiting() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参与者的数量</span></span><br><span class="line">    GetParties() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环栅栏是否处于中断状态</span></span><br><span class="line">    IsBroken() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h3><p>在使用时循环栅栏的参与者只需调用 <code>Await</code> 等待，当所有参与者到达后再执行下一步。当执行下一步时，循环栅栏的状态又恢复到初始状态，可迎接下一轮同样数量的参与者。</p>
<p>假设需求如下：</p>
<ul>
<li><p>  工厂提供多条生产线，每条负责生产氧原子（N 条）或氢原子（2N 条），各由一个 goroutine 负责。</p>
</li>
<li><p>  通过一个栅栏，只有一个氧原子和两个氢原子准备好，才能生成出一个水分子，否则所有生产线都处于等待状态。</p>
</li>
<li><p>  水分子是逐个按照顺序产生的（原子种类和数量有要求）。</p>
</li>
</ul>
<p>需要引入：</p>
<ul>
<li><p>  信号量 semaH：控制氢原子。空槽数资源数设置为 2。</p>
</li>
<li><p>  信号量 semaO：控制氧原子。空槽数资源数设置为 1。</p>
</li>
<li><p>  循环栅栏：等待两个氢原子和一个氧原子填补空槽，直到任务完成。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> H2O <span class="keyword">struct</span> &#123;</span><br><span class="line">    semaH *semaphore.Weighted</span><br><span class="line">    semaO *semaphore.Weighted</span><br><span class="line">    b     cyclicbarrier.CyclicBarrier</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">H2O</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;H2O&#123;</span><br><span class="line">        semaH: semaphore.NewWeighted(<span class="number">2</span>),</span><br><span class="line">        semaO: semaphore.NewWeighted(<span class="number">1</span>),</span><br><span class="line">        b:     cyclicbarrier.New(<span class="number">3</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>氢原子与氧原子的流水线：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h2o *H2O)</span> <span class="title">hydrogen</span><span class="params">(releaseHydrogen <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    h2o.semaH.Acquire(context.Background(), <span class="number">1</span>)</span><br><span class="line">    releaseHydrogen()                     <span class="comment">// 输出 H</span></span><br><span class="line">    h2o.b.Await(context.Background())     <span class="comment">// 等待栅栏放行</span></span><br><span class="line">    h2o.semaH.Release(<span class="number">1</span>)                  <span class="comment">// 释放氢原子空槽</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h2o *H2O)</span> <span class="title">oxygen</span><span class="params">(releaseOxygen <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    h2o.semaO.Acquire(context.Background(), <span class="number">1</span>)</span><br><span class="line">    releaseOxygen()                       <span class="comment">// 输出 O</span></span><br><span class="line">    h2o.b.Await(context.Background())     <span class="comment">// 等待栅栏放行</span></span><br><span class="line">    h2o.semaO.Release(<span class="number">1</span>)                  <span class="comment">// 释放氢原子空槽</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWaterFactory</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 存放水分子结果。</span></span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">    releaseHydrogen := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ch &lt;- <span class="string">&quot;H&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    releaseOxygen := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ch &lt;- <span class="string">&quot;O&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个 goroutine 并发产生一个原子。</span></span><br><span class="line">    <span class="keyword">var</span> N = <span class="number">100</span></span><br><span class="line">    ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, N*<span class="number">3</span>)</span><br><span class="line">    h2o := New()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有 goroutine 完成。</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(N * <span class="number">3</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 氢原子 goroutine。</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>*N; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            time.Sleep(time.Duration(rand.Intn(<span class="number">100</span>)) * time.Millisecond)</span><br><span class="line">            h2o.hydrogen(releaseHydrogen)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 氧原子 goroutine。</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            time.Sleep(time.Duration(rand.Intn(<span class="number">100</span>)) * time.Millisecond)</span><br><span class="line">            h2o.oxygen(releaseOxygen)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//等待所有的 goroutine 执行完</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ch) != N*<span class="number">3</span> &#123;</span><br><span class="line">        t.Fatalf(<span class="string">&quot;expect %d atom but got %d&quot;</span>, N*<span class="number">3</span>, <span class="built_in">len</span>(ch))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分组检查结果。</span></span><br><span class="line">    <span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">        s[<span class="number">0</span>] = &lt;-ch</span><br><span class="line">        s[<span class="number">1</span>] = &lt;-ch</span><br><span class="line">        s[<span class="number">2</span>] = &lt;-ch</span><br><span class="line">        sort.Strings(s)</span><br><span class="line">        water := s[<span class="number">0</span>] + s[<span class="number">1</span>] + s[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> water != <span class="string">&quot;HHO&quot;</span> &#123;</span><br><span class="line">            t.Fatalf(<span class="string">&quot;expect a water molecule but got %s&quot;</span>, water)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ErrGroup-子任务编排"><a href="#ErrGroup-子任务编排" class="headerlink" title="ErrGroup 子任务编排"></a>ErrGroup 子任务编排</h2><p><code>ErrGroup</code> 在 Go 的扩展库中提供，常用于将一个通用的父任务拆成几个小任务并发执行的场景。相比起 <code>WaitGroup</code> 其功能更丰富：</p>
<ul>
<li><p>  和 <code>Context</code> 集成。</p>
</li>
<li><p>  error 向上传播，可把子任务的错误传递给 <code>Wait</code> 的调用者。</p>
</li>
</ul>
<p>提供三个方法：</p>
<ul>
<li><p>  <code>WithContext</code>：传入 <code>Context</code> 以创建 <code>Group</code> 对象。其返回一个 <code>Group</code> 实例以及一个使用 <code>context.WithCancel(ctx)</code> 生成的新 <code>Context</code>。一旦有一个子任务返回错误或是 <code>Wait</code> 调用返回，新 <code>Context</code> 就会被 <code>cancel</code>。如果传递参数是可 <code>cancel</code> 的 <code>Context</code>，则其被 <code>cancel</code> 时不会终止正在执行的子任务。</p>
</li>
<li><p>  <code>Go</code>：传入一个无参、带 error 返回值的函数，创建 goroutine 执行子任务。</p>
</li>
<li><p>  <code>Wait</code>：阻塞直到所有子任务完成后才返回。如多个子任务返回错误，则只会返回第一个出现的错误，所有子任务都执行成功则返回 nil。</p>
</li>
</ul>
<p>默认只返回第一个错误，如要实现收集所有子任务执行结果，可使用全局变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g errgroup.Group</span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">make</span>([]error, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个子任务执行成功。</span></span><br><span class="line">g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;exec #1&quot;</span>)</span><br><span class="line">    result[<span class="number">0</span>] = <span class="literal">nil</span> <span class="comment">// 保存成功或者失败的结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个子任务执行失败。</span></span><br><span class="line">g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;exec #2&quot;</span>)</span><br><span class="line">    result[<span class="number">1</span>] = errors.New(<span class="string">&quot;failed to exec #2&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">1</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个子任务执行成功。</span></span><br><span class="line">g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">15</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;exec #3&quot;</span>)</span><br><span class="line">    result[<span class="number">2</span>] = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// err 为第一个错误。</span></span><br><span class="line"><span class="keyword">if</span> err := g.Wait(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Successfully exec all. result: %v\n&quot;</span>, result)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;failed: %v\n&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-Pipeline"><a href="#实现-Pipeline" class="headerlink" title="实现 Pipeline"></a>实现 Pipeline</h3><p>官方文档提供的 <a target="_blank" rel="noopener" href="https://godoc.org/golang.org/x/sync/errgroup#example-Group--Pipeline">例子</a>：一个子任务遍历目录下的文件，把遍历出的文件交给 20 个 goroutine、并行计算文件的 md5。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m, err := MD5All(context.Background(), <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, sum := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s:\t%x\n&quot;</span>, k, sum)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">    path <span class="keyword">string</span></span><br><span class="line">    sum  [md5.Size]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历根目录下所有的文件和子目录，计算它们的 md5 值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MD5All</span><span class="params">(ctx context.Context, root <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>][md5.Size]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    g, ctx := errgroup.WithContext(ctx)</span><br><span class="line">    paths := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历文件路径：写入 paths。</span></span><br><span class="line">    g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(paths)</span><br><span class="line">        <span class="keyword">return</span> filepath.Walk(root, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="keyword">string</span>, info os.FileInfo, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            <span class="comment">// ... 将文件路径放入 paths</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并行从 paths 取出文件、计算 md5，将结果写入 c。</span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> result)</span><br><span class="line">    <span class="keyword">const</span> numDigesters = <span class="number">20</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numDigesters; i++ &#123;</span><br><span class="line">        g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> path := <span class="keyword">range</span> paths &#123; <span class="comment">// 遍历直到 paths chan 被关闭</span></span><br><span class="line">                <span class="comment">// ... 计算 path 的 md5 值，放入 c 中。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待遍历目录和计算 md5 的 goroutine 执行完成，关闭 c。</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        g.Wait()</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 md5 结果从 chan 中读取到 map，直到 c 被关闭。</span></span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][md5.Size]<span class="keyword">byte</span>)</span><br><span class="line">    <span class="keyword">for</span> r := <span class="keyword">range</span> c &#123; </span><br><span class="line">        m[r.path] = r.sum</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次调用 Wait，依然可以得到 group 的 error 信息</span></span><br><span class="line">    <span class="keyword">if</span> err := g.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ErrGroup</code> 也存在一些问题：如果无限制地直接调用 <code>Go</code> 方法，就会创建出非常多 goroutine，会带来调度和 GC 的压力、占用更多内存。当前 Go 运行时创建的 g 对象只会增长和重用，不会回收。在高并发场景下要尽可能减少 goroutine 的使用（比如使用 Work Pool 或类似 <a target="_blank" rel="noopener" href="https://github.com/containerd/stargz-snapshotter/pull/157">containerd/stargz-snapshotter</a> 的方案，信号量的资源数就是可并行的 goroutine 的数量）。</p>
<h3 id="扩展库"><a href="#扩展库" class="headerlink" title="扩展库"></a>扩展库</h3><p>很多在 Go 官方 <code>ErrGroup</code> 基础上进行扩展、或自行实现分组功能的第三方库，提供了更多更丰富的功能：</p>
<ul>
<li><p>  <a target="_blank" rel="noopener" href="https://pkg.go.dev/github.com/bilibili/kratos/pkg/sync/errgroup">bilibili/errgroup</a>：可以使用固定数量的 goroutine 处理子任务。并提供了 cancel（失败的子任务可以 cancel 所有正在执行任务）和 recover（把 panic 的堆栈信息放到 error 中，避免子任务 panic 导致的程序崩溃）功能。但一旦设置了并发数，超过并发数的子任务需要等到调用者调用 <code>Wait</code> 之后才执行（而不是 goroutine 空闲下来就自动执行）。而且在高并发下如果任务数大于 goroutine 数，且任务被集中加入到 Group 中，该库会把子任务加入到一个非线程安全的数组。</p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://github.com/neilotoole/errgroup">neilotoole/errgroup</a>：对标准库 <code>WaitGroup</code> 的扩展。其 <code>Wait</code> 方法可返回一或多个 error。子任务在调用 <code>Done</code> 之前可把自己的 error 信息设置给 <code>ErrGroup</code>。在 <code>Wait</code> 返回时，把这些 error 信息返回给调用者。</p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://github.com/go-pkgz/syncs">go-pkgz/syncs</a>：提供了 <code>SizedGroup</code> 和 <code>ErrSizedGroup</code>，支持直接控制子任务的并发数（而不是 goroutine 数），并提供相应的 failfast 的错误处理能力。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/vardius/gollback">vardius/gollback</a>：用于处理一组子任务的执行，且解决了 <code>ErrGroup</code> 收集子任务返回结果的痛点。其提供三个方法：</p>
<ul>
<li><p>  <code>All</code>：等待所有的异步函数都执行完才返回执行结果和错误信息，且返回结果的顺序与传入函数的顺序保持一致。</p>
</li>
<li><p>  <code>Race</code>：与 <code>All</code> 方法类似，但在使用时只要一个异步函数执行成功就马上返回，不会返回所有的子任务信息。只有全部失败才返回最后一个 error 信息。</p>
</li>
<li><p>  <code>Retry</code>：执行一个子任务，执行失败就会尝试一定次数（为 0 则一致尝试直到成功），如一直不成功就会返回错误信息 ，否则它会立即返回。</p>
</li>
</ul>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://github.com/AaronJan/Hunch">AaronJan/Hunch</a>：和 gollback 类似，但提供的方法更多（<code>All</code>、<code>Take</code>、<code>Last</code>、<code>Retry</code>、<code>Waterfall</code> 等）。</p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://github.com/mdlayher/schedgroup">mdlayher/schedgroup</a>：提供与时间相关、处理一组 goroutine 的并发原语 schedgroup，可指定任务在某时间后执行（提供 <code>Delay</code>、<code>Schedule</code>、<code>Wait</code> 等方法）。</p>
</li>
</ul>
<p>待续。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p>  <a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html">Goroutine Leaks - The Forgotten Sender (ardanlabs.com)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html">Concurrency Trap #2: Incomplete Work (ardanlabs.com)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html">Concurrency, Goroutines and GOMAXPROCS (ardanlabs.com)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_concurrency">Practical Go: Real world advice for writing maintainable Go programs (cheney.net)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://golang.org/ref/mem">The Go Memory Model - The Go Programming Language (golang.org)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/caoshangpa/article/details/78853919">理解Memory Barrier（内存屏障）_草上爬的博客-CSDN博客</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/qcrao/article/details/92759907">曹大谈内存重排_梦醒人间-CSDN博客</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://cch123.github.io/ooo/">从 Memory Reordering 说起 (cch123.github.io)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://blog.golang.org/codelab-share">Share Memory By Communicating - The Go Blog (golang.org)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://dave.cheney.net/2018/01/06/if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package">If aligned memory writes are atomic, why do we need the sync/atomic package? – The acme of foolishness (cheney.net)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://blog.golang.org/race-detector">Introducing the Go Race Detector - The Go Blog (golang.org)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races">Ice cream makers and data races – The acme of foolishness (cheney.net)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html">Ice Cream Makers and Data Races Part II (ardanlabs.com)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-how-to-reduce-lock-contention-with-the-atomic-package-ba3b2664b549">Go: How to Reduce Lock Contention with the Atomic Package | by Vincent Blanchon | A Journey With Go | Medium</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-discovery-of-the-trace-package-e5a821743c3c">Go: Discovery of the Trace Package | by Vincent Blanchon | A Journey With Go | Medium</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-mutex-and-starvation-3f4f4e75ad50">Go: Mutex and Starvation. While developing in Golang, a mutex can… | by Vincent Blanchon | A Journey With Go | Medium</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html">The Behavior Of Channels (ardanlabs.com)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-buffered-and-unbuffered-channels-29a107c00268">Go: Buffered and Unbuffered Channels | by Vincent Blanchon | A Journey With Go | Medium</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-ordering-in-select-statements-fd0ff80fd8d6">Go: Ordering in Select Statements | by Vincent Blanchon | A Journey With Go | Medium</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html">The Nature Of Channels In Go (ardanlabs.com)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2013/10/my-channel-select-bug.html">My Channel Select Bug (ardanlabs.com)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://blog.golang.org/io2013-talk-concurrency">Advanced Go Concurrency Patterns - The Go Blog (golang.org)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://blog.golang.org/waza-talk">Concurrency is not parallelism - The Go Blog (golang.org)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://blog.golang.org/io2012-videos">Go videos from Google I/O 2012 - The Go Blog (golang.org)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://blog.golang.org/concurrency-timeouts">Go Concurrency Patterns: Timing out, moving on - The Go Blog (golang.org)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://blog.golang.org/pipelines">Go Concurrency Patterns: Pipelines and cancellation - The Go Blog (golang.org)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2014/02/running-queries-concurrently-against.html">Running MongoDB Queries Concurrently With Go (ardanlabs.com)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://blogtitle.github.io/go-advanced-concurrency-patterns-part-3-channels/">Go advanced concurrency patterns: part 3 (channels) - Blog Title</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2013/05/thread-pooling-in-go-programming.html">Thread Pooling in Go Programming (ardanlabs.com)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2013/09/pool-go-routines-to-process-task.html">Pool Go Routines To Process Task Oriented Work (ardanlabs.com)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://blogtitle.github.io/categories/concurrency/">Concurrency - Blog Title</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://golang.org/ref/spec#Channel_types">The Go Programming Language Specification - The Go Programming Language (golang.org)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view">Rethinking Classical Concurrency Patterns.pdf - Google 云端硬盘</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-context-and-cancellation-by-propagation-7a808bbc889c">Go: Context and Cancellation by Propagation | by Vincent Blanchon | A Journey With Go | Medium</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://blog.golang.org/context">Go Concurrency Patterns: Context - The Go Blog (golang.org)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2019/09/context-package-semantics-in-go.html">Context Package Semantics In Go (ardanlabs.com)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://golang.org/doc/effective_go#concurrency">Effective Go - The Go Programming Language (golang.org)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34417106?hmsr=toutiao.io">Go Context的踩坑经历 - 知乎 (zhihu.com)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://talks.golang.org/2014/gotham-context.slide#1">Cancelation, Context, and Plumbing (golang.org)</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39">How to correctly use context.Context in Go 1.7 | by Jack Lindamood | Medium</a></p>
</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    </article>
    <!-- license  -->
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2021/10/10/Design_data-lineage/" title= "数据血缘功能设计">
                    <div class="prevTitle">数据血缘功能设计</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

    <div id="lv-container" data-id="city" data-uid= MTAyMC80ODYzMi8yNTEyNg==>
        <script type="text/javascript">
            (function (d, s) {
                var j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') { return; }
                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

<!-- City版安装代码已完成 -->
    
    
     
    <!-- utteranc评论 -->

    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->

    <!-- idea from: https://hexo.fluid-dev.com/posts/hexo-injector/#%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%80%A7%E6%8F%90%E7%A4%BA -->
    
</main>

            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:yipwinghong@outlook.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/yipwinghong" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                    
                    <img class="profile-qr" src="https://ywh-oss.oss-cn-shenzhen.aliyuncs.com/WeChat.jpg" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="https://www.v2ex.com/member/yipwinghong" class="iconfont-archer v2ex" target="_blank" title=v2ex></a>
            
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title=rss></a>
            
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- website approve for Chinese user -->
    
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:100vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Go-%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.</span> <span class="toc-text">Go 并发原语</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Mutex-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">1.1.</span> <span class="toc-text">Mutex 互斥锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">1.1.1.</span> <span class="toc-text">实现细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%A1%BB%E7%9F%A5"><span class="toc-number">1.1.2.</span> <span class="toc-text">使用须知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%AE%9E%E7%8E%B0-TryLock"><span class="toc-number">1.1.3.</span> <span class="toc-text">扩展：实现 TryLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E8%8E%B7%E5%8F%96-Waiter-%E6%95%B0%E9%87%8F%E7%AD%89%E6%8C%87%E6%A0%87"><span class="toc-number">1.1.4.</span> <span class="toc-text">扩展：获取 Waiter 数量等指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97"><span class="toc-number">1.1.5.</span> <span class="toc-text">扩展：实现线程安全队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RWMutex-%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.2.</span> <span class="toc-text">RWMutex 读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">实现细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%A1%BB%E7%9F%A5-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">使用须知</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WaitGroup-%E7%AD%89%E5%BE%85%E7%BB%84"><span class="toc-number">1.3.</span> <span class="toc-text">WaitGroup 等待组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">实现细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%A1%BB%E7%9F%A5-2"><span class="toc-number">1.3.2.</span> <span class="toc-text">使用须知</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cond-%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">Cond 条件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82-3"><span class="toc-number">1.4.1.</span> <span class="toc-text">实现细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%A1%BB%E7%9F%A5-3"><span class="toc-number">1.4.2.</span> <span class="toc-text">使用须知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%AE%9E%E7%8E%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">1.4.3.</span> <span class="toc-text">扩展：实现阻塞队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Once-%E5%8D%95%E4%BE%8B"><span class="toc-number">1.5.</span> <span class="toc-text">Once 单例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82-4"><span class="toc-number">1.5.1.</span> <span class="toc-text">实现细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%A1%BB%E7%9F%A5-4"><span class="toc-number">1.5.2.</span> <span class="toc-text">使用须知</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pool-%E6%B1%A0"><span class="toc-number">1.6.</span> <span class="toc-text">Pool 池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82-5"><span class="toc-number">1.6.1.</span> <span class="toc-text">实现细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%A1%BB%E7%9F%A5-5"><span class="toc-number">1.6.2.</span> <span class="toc-text">使用须知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Worker-Pool"><span class="toc-number">1.6.3.</span> <span class="toc-text">Worker Pool</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Context-%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.7.</span> <span class="toc-text">Context 上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A-Context"><span class="toc-number">1.7.1.</span> <span class="toc-text">特殊 Context</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WithValue"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">WithValue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WithCancel"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">WithCancel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WithTimeout"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">WithTimeout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WithDeadline"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">WithDeadline</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86-goroutine-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.7.2.</span> <span class="toc-text">管理 goroutine 生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%A1%BB%E7%9F%A5-6"><span class="toc-number">1.7.3.</span> <span class="toc-text">使用须知</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">参数传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A7%E8%81%94%E5%8F%96%E6%B6%88"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">级联取消</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E8%B0%83%E7%94%A8"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">超时调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.7.3.4.</span> <span class="toc-text">作用域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Atomic-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">1.8.</span> <span class="toc-text">Atomic 原子操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95"><span class="toc-number">1.8.1.</span> <span class="toc-text">功能扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97"><span class="toc-number">1.8.2.</span> <span class="toc-text">扩展：实现无锁队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.9.</span> <span class="toc-text">Semaphore 信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#P-V-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.9.1.</span> <span class="toc-text">P&#x2F;V 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.9.2.</span> <span class="toc-text">标准库实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Channel-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.9.3.</span> <span class="toc-text">使用 Channel 实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SingleFlight-%E8%AF%B7%E6%B1%82%E5%90%88%E5%B9%B6"><span class="toc-number">1.10.</span> <span class="toc-text">SingleFlight 请求合并</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.10.1.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.10.2.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CyclicBarrier-%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F"><span class="toc-number">1.11.</span> <span class="toc-text">CyclicBarrier 循环栅栏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1"><span class="toc-number">1.11.1.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8"><span class="toc-number">1.11.2.</span> <span class="toc-text">基本应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ErrGroup-%E5%AD%90%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92"><span class="toc-number">1.12.</span> <span class="toc-text">ErrGroup 子任务编排</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-Pipeline"><span class="toc-number">1.12.1.</span> <span class="toc-text">实现 Pipeline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%BA%93"><span class="toc-number">1.12.2.</span> <span class="toc-text">扩展库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.13.</span> <span class="toc-text">参考</span></a></li></ol></li></ol>
    </div>
    
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 77
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2021 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/15</span><a class="archive-post-title" href= "/2021/10/15/Go_concurrency_primitives/" >Go 并发原语</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/10</span><a class="archive-post-title" href= "/2021/10/10/Design_data-lineage/" >数据血缘功能设计</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/26</span><a class="archive-post-title" href= "/2021/09/26/2021-09-26_diary/" >迟来的一次复盘</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/12</span><a class="archive-post-title" href= "/2021/09/12/DB_mysql-optimization-basic/" >MySQL 性能优化基础</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/05</span><a class="archive-post-title" href= "/2021/09/05/DB_b-trees-more-than-i-thought-id-want-to-know/" >关于 B-Trees 的更多细节（译）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/27</span><a class="archive-post-title" href= "/2021/08/27/DDIA_note-15/" >《DDIA》阅读笔记（十一）：流处理系统</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/11</span><a class="archive-post-title" href= "/2021/08/11/Go_microservices_availability_design/" >微服务可用性设计</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/10</span><a class="archive-post-title" href= "/2021/08/10/Algorithm_reliable-distributed-timer/" >可靠的分布式计时器（译）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/04</span><a class="archive-post-title" href= "/2021/08/04/Go_engineering-standard/" >Go 工程化标准实践</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/31</span><a class="archive-post-title" href= "/2021/07/31/Go_memory-model/" >Go 内存模型（译）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/28</span><a class="archive-post-title" href= "/2021/07/28/Go_channel-applications/" >Go Channel 应用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/25</span><a class="archive-post-title" href= "/2021/07/25/Fenix_build-services/" >《凤凰架构》阅读笔记（五）：服务构建与流量治理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/23</span><a class="archive-post-title" href= "/2021/07/23/Fenix_transparent-multilevel-diversion-system/" >《凤凰架构》阅读笔记（四）：透明多级分流系统</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/22</span><a class="archive-post-title" href= "/2021/07/22/Fenix_transaction/" >《凤凰架构》阅读笔记（三）：事务处理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/21</span><a class="archive-post-title" href= "/2021/07/21/Fenix_access-remote-service/" >《凤凰架构》阅读笔记（二）：访问远程服务</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/18</span><a class="archive-post-title" href= "/2021/07/18/Go_error_handling/" >Go 异常处理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/15</span><a class="archive-post-title" href= "/2021/07/15/Fenix_architecture-evolution/" >《凤凰架构》阅读笔记（一）：软件架构演进</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/12</span><a class="archive-post-title" href= "/2021/07/12/Go_microservices_governance/" >微服务概览与治理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/09</span><a class="archive-post-title" href= "/2021/07/09/Algorithm_max-flow-problem/" >最大流问题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/08</span><a class="archive-post-title" href= "/2021/07/08/Algorithm_minimum_spanning_tree_problem/" >最小生成树问题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/08</span><a class="archive-post-title" href= "/2021/07/08/Algorithm_shortest-path-problem/" >最短路径问题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/01</span><a class="archive-post-title" href= "/2021/07/01/DistributedSystem_gossip-dissemination/" >分布式系统模式：Gossip 传播（译）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/23</span><a class="archive-post-title" href= "/2021/06/23/DistributedSystem_versioned-value/" >分布式系统模式：版本化值（译）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/19</span><a class="archive-post-title" href= "/2021/06/19/Algorithm_consistent-hashing/" >一致性哈希（译）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/13</span><a class="archive-post-title" href= "/2021/06/13/Go_cheat-sheet/" >Go Cheat Sheet</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/10</span><a class="archive-post-title" href= "/2021/06/10/Go_a-tour-of-go/" >A tour of Go</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/06</span><a class="archive-post-title" href= "/2021/06/06/2021-06-06_diary/" >Weekly Summary (2021-05-31_2021-06-06)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/05</span><a class="archive-post-title" href= "/2021/06/05/2021-06-05_diary/" >基于记忆规律的学习方法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/31</span><a class="archive-post-title" href= "/2021/05/31/2021-05-31_diary/" >2021 下半年工作学习安排</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/16</span><a class="archive-post-title" href= "/2021/05/16/Algorithm_how-to-solve-the-secret-santa-problem-using-graph-theory/" >如何用图论解决 Secret Santa 问题？（译）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/12</span><a class="archive-post-title" href= "/2021/05/12/DB_using-postgresql-as-a-data-warehouse/" >把 PostgreSQL 用作数据仓库（译）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/28</span><a class="archive-post-title" href= "/2021/04/28/OS_linux-memory-monitoring/" >Linux 内存原理与分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/20</span><a class="archive-post-title" href= "/2021/04/20/OS_linux-io-monitoring/" >Linux I/O 原理与分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/10</span><a class="archive-post-title" href= "/2021/04/10/OS_linux-cpu-monitoring/" >Linux CPU 原理与分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/05</span><a class="archive-post-title" href= "/2021/04/05/OS_linux-network-monitoring/" >Linux 网络原理与分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/01</span><a class="archive-post-title" href= "/2021/04/01/OS_system_initialization/" >Linux - 架构与系统初始化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/17</span><a class="archive-post-title" href= "/2021/03/17/Java_cpp-for-java-programmers/" >Java 程序员的 C++（译）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/24</span><a class="archive-post-title" href= "/2021/02/24/DDIA_note-13/" >《DDIA》阅读笔记（九）：一致性与共识（共识问题）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/21</span><a class="archive-post-title" href= "/2021/02/21/2021-02-21_diary/" >近期工作学习规划</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/19</span><a class="archive-post-title" href= "/2021/02/19/DDIA_note-12/" >《DDIA》阅读笔记（九）：一致性与共识（顺序保证）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/13</span><a class="archive-post-title" href= "/2021/02/13/DDIA_note-11/" >《DDIA》阅读笔记（九）：一致性与共识（可线性化）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/06</span><a class="archive-post-title" href= "/2021/02/06/DDIA_note-10/" >《DDIA》阅读笔记（八）：分布式系统的挑战</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/27</span><a class="archive-post-title" href= "/2021/01/27/DDIA_note-9/" >《DDIA》阅读笔记（七）：事务</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/22</span><a class="archive-post-title" href= "/2021/01/22/DDIA_note-8/" >《DDIA》阅读笔记（六）：数据分区</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/21</span><a class="archive-post-title" href= "/2021/01/21/DDIA_note-7/" >《DDIA》阅读笔记（五）：数据复制（无主节点）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/20</span><a class="archive-post-title" href= "/2021/01/20/DDIA_note-6/" >《DDIA》阅读笔记（五）：数据复制（多主节点）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/10</span><a class="archive-post-title" href= "/2021/01/10/DB_right-database/" >选择合适的数据库（译）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/09</span><a class="archive-post-title" href= "/2021/01/09/DDIA_note-5/" >《DDIA》阅读笔记（五）：数据复制（单主节点）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/01</span><a class="archive-post-title" href= "/2021/01/01/DB_tree-table-design-summary/" >树形表结构设计总结</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/13</span><a class="archive-post-title" href= "/2020/12/13/DDIA_note-3/" >《DDIA》阅读笔记（三）：数据存储与检索</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/04</span><a class="archive-post-title" href= "/2020/12/04/DDIA_note-2/" >《DDIA》阅读笔记（二）：数据模型与查询语言</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/02</span><a class="archive-post-title" href= "/2020/12/02/DDIA_note-1/" >《DDIA》阅读笔记（一）：可靠、可扩展与可维护的应用系统</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/08</span><a class="archive-post-title" href= "/2020/10/08/Maven_external_dependencies_management/" >Maven 打包依赖外置</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/04</span><a class="archive-post-title" href= "/2020/10/04/Java_prod-analysis-cmd/" >Java 应用常用调试分析方法总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/24</span><a class="archive-post-title" href= "/2020/09/24/Kafka_cheat-sheet/" >Kafka Cheat Sheet</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/09</span><a class="archive-post-title" href= "/2020/08/09/Arthas_cheat-sheet/" >Arthas Cheat Sheet</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/12</span><a class="archive-post-title" href= "/2020/07/12/Java_override-and-bridge-method/" >Java 多态、重写与桥接方法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/30</span><a class="archive-post-title" href= "/2020/06/30/Java_memory-area/" >Java 内存区域</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/28</span><a class="archive-post-title" href= "/2020/05/28/DB_data-warehouse-design-basic/" >数据仓库设计基础</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/08</span><a class="archive-post-title" href= "/2020/04/08/2020-04-08_diary/" >关于使用思维导图做笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/28</span><a class="archive-post-title" href= "/2020/03/28/Algorithm_leetcode-high-frequency-problems/" >LeetCode 高频面试题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/06</span><a class="archive-post-title" href= "/2020/03/06/InfoSecty_personal-infomation-security-guide/" >個人信息安全保護指南</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/22</span><a class="archive-post-title" href= "/2020/02/22/2020-02-22_diary/" >免费 JetBrains 全家桶</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/16</span><a class="archive-post-title" href= "/2020/02/16/Nginx_cheat-sheet/" >Nginx Cheat Sheet</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/15</span><a class="archive-post-title" href= "/2020/02/15/Git_cheat-sheet/" >Git Cheat Sheet</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/15</span><a class="archive-post-title" href= "/2020/02/15/Docker&K8S_cheat-sheet/" >Docker & K8S Cheat Sheet</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/03</span><a class="archive-post-title" href= "/2020/02/03/Java_jstat-monitor-analysis/" >JVM jstat 监控分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/01</span><a class="archive-post-title" href= "/2020/02/01/Java_GC-log-analysis/" >JVM GC 日志分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/01</span><a class="archive-post-title" href= "/2020/01/01/Java_JVM_mindmap/" >Java 虚拟机与并发编程</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/05</span><a class="archive-post-title" href= "/2019/12/05/Design_design-patterns/" >设计模式与设计原则</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/04</span><a class="archive-post-title" href= "/2019/10/04/Python_async-programming/" >Python 异步编程总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/19</span><a class="archive-post-title" href= "/2019/09/19/Python_data-structure/" >Python 数据结构应用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/13</span><a class="archive-post-title" href= "/2019/09/13/Python_decorator/" >Python 装饰器基本用法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/22</span><a class="archive-post-title" href= "/2019/08/22/Python_OOP-summary/" >Python 类与对象总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/28</span><a class="archive-post-title" href= "/2019/06/28/JavaScript_cheat-sheet/" >JavaScript Cheat Sheet</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/02</span><a class="archive-post-title" href= "/2019/06/02/JavaScript_ES6-grammar/" >ES6 语法总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/20</span><a class="archive-post-title" href= "/2019/05/20/Vue_user-guide/" >Vue 学习笔记</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="技术"><span class="iconfont-archer">&#xe606;</span>技术</span>
    
        <span class="sidebar-tag-name" data-tags="杂事"><span class="iconfont-archer">&#xe606;</span>杂事</span>
    
        <span class="sidebar-tag-name" data-tags="算法"><span class="iconfont-archer">&#xe606;</span>算法</span>
    
        <span class="sidebar-tag-name" data-tags="Java"><span class="iconfont-archer">&#xe606;</span>Java</span>
    
        <span class="sidebar-tag-name" data-tags="数据库"><span class="iconfont-archer">&#xe606;</span>数据库</span>
    
        <span class="sidebar-tag-name" data-tags="大数据"><span class="iconfont-archer">&#xe606;</span>大数据</span>
    
        <span class="sidebar-tag-name" data-tags="设计"><span class="iconfont-archer">&#xe606;</span>设计</span>
    
        <span class="sidebar-tag-name" data-tags="分布式系统"><span class="iconfont-archer">&#xe606;</span>分布式系统</span>
    
        <span class="sidebar-tag-name" data-tags="Docker"><span class="iconfont-archer">&#xe606;</span>Docker</span>
    
        <span class="sidebar-tag-name" data-tags="Kubernetes"><span class="iconfont-archer">&#xe606;</span>Kubernetes</span>
    
        <span class="sidebar-tag-name" data-tags="Go"><span class="iconfont-archer">&#xe606;</span>Go</span>
    
        <span class="sidebar-tag-name" data-tags="信息安全"><span class="iconfont-archer">&#xe606;</span>信息安全</span>
    
        <span class="sidebar-tag-name" data-tags="Maven"><span class="iconfont-archer">&#xe606;</span>Maven</span>
    
        <span class="sidebar-tag-name" data-tags="Nginx"><span class="iconfont-archer">&#xe606;</span>Nginx</span>
    
        <span class="sidebar-tag-name" data-tags="Linux"><span class="iconfont-archer">&#xe606;</span>Linux</span>
    
        <span class="sidebar-tag-name" data-tags="OS"><span class="iconfont-archer">&#xe606;</span>OS</span>
    
        <span class="sidebar-tag-name" data-tags="Python"><span class="iconfont-archer">&#xe606;</span>Python</span>
    
        <span class="sidebar-tag-name" data-tags="Git"><span class="iconfont-archer">&#xe606;</span>Git</span>
    
        <span class="sidebar-tag-name" data-tags="微服务"><span class="iconfont-archer">&#xe606;</span>微服务</span>
    
        <span class="sidebar-tag-name" data-tags="JavaScript"><span class="iconfont-archer">&#xe606;</span>JavaScript</span>
    
        <span class="sidebar-tag-name" data-tags="MySQL"><span class="iconfont-archer">&#xe606;</span>MySQL</span>
    
        <span class="sidebar-tag-name" data-tags="Kafka"><span class="iconfont-archer">&#xe606;</span>Kafka</span>
    
        <span class="sidebar-tag-name" data-tags="Vue"><span class="iconfont-archer">&#xe606;</span>Vue</span>
    
        <span class="sidebar-tag-name" data-tags="前端"><span class="iconfont-archer">&#xe606;</span>前端</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="《数据密集型应用系统设计》阅读笔记"><span class="iconfont-archer">&#xe60a;</span>《数据密集型应用系统设计》阅读笔记</span>
    
        <span class="sidebar-category-name" data-categories="《凤凰架构》阅读笔记"><span class="iconfont-archer">&#xe60a;</span>《凤凰架构》阅读笔记</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Kylo Yip"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>


