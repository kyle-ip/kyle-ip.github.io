<!DOCTYPE html>
<html lang="en">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Kylo Yip">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Kylo Yip">
	
	<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
    <script src="/live2d-widget/autoload.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/>
	
    
    <meta name="keywords" content="Kylo's Notebook,Kylo Yip">
    
    <meta name="description" content="">
    <meta name="description" content="学会 Linux 系统原理，并使用命令行工具分析 Linux 系统问题（CPU）。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux CPU 原理与分析">
<meta property="og:url" content="https://yipwinghong.github.io/2021/04/16/OS_linux-cpu-monitoring/index.html">
<meta property="og:site_name" content="Kylo&#39;s Notebook">
<meta property="og:description" content="学会 Linux 系统原理，并使用命令行工具分析 Linux 系统问题（CPU）。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ywh-oss.oss-cn-shenzhen.aliyuncs.com/OS_linux-cpu-monitoring.assets/596397e1d6335d2990f70427ad4b14ec.png">
<meta property="og:image" content="https://ywh-oss.oss-cn-shenzhen.aliyuncs.com/OS_linux-cpu-monitoring.assets/b0c67a7196f5ca4cc58f14f959a364ca.png">
<meta property="og:image" content="https://ywh-oss.oss-cn-shenzhen.aliyuncs.com/OS_linux-cpu-monitoring.assets/7a445960a4bc0a58a02e1bc75648aa17.png">
<meta property="article:published_time" content="2021-04-16T11:50:33.000Z">
<meta property="article:modified_time" content="2021-07-19T08:37:55.205Z">
<meta property="article:author" content="Kylo Yip">
<meta property="article:tag" content="技术">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ywh-oss.oss-cn-shenzhen.aliyuncs.com/OS_linux-cpu-monitoring.assets/596397e1d6335d2990f70427ad4b14ec.png">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    
    <title>Linux CPU 原理与分析 · Kylo&#39;s Notebook</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20210204" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20210204" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js?v=20210204" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    <script src="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.3/js/all.min.js"  data-auto-replace-svg="nest" ></script>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Kylo's Notebook" type="application/atom+xml">
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <!-- top read progress line -->
    <div class="header-element">
        
        <div class="read-progress"></div>
        
    </div>
    <!-- sidebar menu button -->
    <div class="header-element">
        
        <div class="header-sidebar-menu header-sidebar-menu-rounded">
        
            
            <i class="fas fa-bars"></i>
            
        </div>
    </div>
    <!-- back to home page text -->
    <a class="home-link header-element" href=/>Kylo's Notebook</a>
    <!-- toggle banner for post layout -->
    
    
    <div class="banner">
    
        <div class="blog-title header-element">
            <a href="/" >Kylo&#39;s Notebook</a>
        </div>
        <div class="post-title header-element">
            <a href="#" class="post-name">Linux CPU 原理与分析</a>
        </div>
    </div>
    
</header>
    
<footer class="footer-fixed">

    <!-- back to top button -->
    <div class="footer-fixed-element">
        
        <div class="back-top back-top-rounded">
        
            
            <i class="fas fa-chevron-up"></i>
            
        </div>
    </div>
</footer>
    <div class="wrapper">
        <div class="site-intro" style="







height:100vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(https://api.ixiaowai.cn/mcapi/mcapi.php)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Linux CPU 原理与分析
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "技术">技术</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "Linux">Linux</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "OS">OS</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">8.6k</span>Reading time: <span class="post-count reading-time">35 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2021/04/16</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="Linux-CPU-原理与分析"><a href="#Linux-CPU-原理与分析" class="headerlink" title="Linux CPU 原理与分析"></a>Linux CPU 原理与分析</h1><blockquote class="pullquote mindmap mindmap-md"><ul>
<li>CPU 性能指标<ul>
<li>CPU 使用率<ul>
<li>用户 CPU</li>
<li>内核 CPU</li>
<li>IOWAIT</li>
<li>软中断</li>
<li>硬中断</li>
<li>窃取 CPU</li>
<li>客户 CPU</li>
</ul>
</li>
<li>上下文切换<ul>
<li>自愿上下文切换</li>
<li>非自愿上下文切换</li>
</ul>
</li>
<li>平均负载</li>
<li>CPU 缓存命中率</li>
</ul>
</li>
</ul>
</blockquote>

<h2 id="平均负载（Load-Average）"><a href="#平均负载（Load-Average）" class="headerlink" title="平均负载（Load Average）"></a>平均负载（Load Average）</h2><p>使用 <code>top</code> 或 <code>uptime</code> 命令，都会有以下输出（其中 load average 表示过去 1、5、15 分钟的平均负载）：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">02</span>:<span class="number">34</span>:<span class="number">03</span> up <span class="number">2</span> days, <span class="number">20</span>:<span class="number">14</span>,  <span class="number">1</span> user,  load average: <span class="number">0</span>.<span class="number">63</span>, <span class="number">0</span>.<span class="number">83</span>, <span class="number">0</span>.<span class="number">88</span></span><br></pre></td></tr></table></figure>

<p>平均负载可理解为单位时间内，系统处于 <strong>可运行状态</strong> 和 <strong>不可中断状态</strong> 的 平均进程数，即 <strong>平均活跃进程数</strong>，与 CPU 使用率没有直接关系。</p>
<ul>
<li><p>  可运行状态：正在使用或等待 CPU 的进程，即使用 <code>ps</code> 命令可见状态为 R 的进程（Running/Runnable）。</p>
</li>
<li><p>  不可中断状态：处于内核态关键流程中、不可打断的进程，比如等待 I/O，使用 <code>ps</code> 命令可见状态为 D 的进程（Disk Sleep）。</p>
</li>
</ul>
<h3 id="如何监控？"><a href="#如何监控？" class="headerlink" title="如何监控？"></a>如何监控？</h3><ul>
<li><p>  平均负载的值可表示系统的繁忙程度，最理想的情况是等于 CPU 核心数（逻辑 CPU，<code>grep &#39;model name&#39; /proc/cpuinfo | wc -l</code>）。当平均负载值小于 CPU 核心数表示有空闲，大于 CPU 核心数表示有进程竞争不到 CPU。</p>
</li>
<li><p>  如果 1、5、15 分钟的值基本相同或相差不大，表明系统负载平稳。</p>
</li>
<li><p>  如果 1 分钟的值远小于 15 分钟的值，表明系统最近 1 分钟负载在减少，而过去 15 分钟内却有很大的负载。</p>
</li>
<li><p>  如果 1 分钟的值远大于 15 分钟的值，就说明最近 1 分钟的负载在增加，需要持续观察这种情况是临时性还是持续性。当 1 分钟的平均负载接近或超过了 CPU 核心数，意味着系统正在过载，应该分析调查原因并做出优化。</p>
</li>
</ul>
<p>经验上平均负载超过 CPU 核心数的 70%~80% 需要分析排查负载高的原因，根据更多历史数据判断负载的变化趋势。</p>
<h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><p>安装监控及测试工具：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt install -y stress sysstat</span><br><span class="line"><span class="meta">#</span><span class="bash"> 分析工具由 sysstat 提供：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mpstat：多核 CPU 性能分析工具，实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pidstat：进程性能分析工具，实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。</span></span><br></pre></td></tr></table></figure>

<p>模拟 CPU 使用率 100% 场景：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --cpu 1 --timeout 600</span><br></pre></td></tr></table></figure>

<p>观察平均负载变化：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watch -d uptime    # -d 参数表示高亮显示变化的区域</span><br><span class="line"><span class="meta">#</span><span class="bash"> ..., load average: 1.00, 0.75, 0.39</span></span><br></pre></td></tr></table></figure>

<p>观察 CPU 使用率变化：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mpstat -P ALL 5    # -P ALL 表示监控所有 CPU，其中主要参考 CPU、iowait 等。</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可见 %user 100%。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 13:30:06     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 13:30:11     all   50.05    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   49.95</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 13:30:11       0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 13:30:11       1  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span></span><br></pre></td></tr></table></figure>

<p>找出导致 CPU 使用率 100% 的进程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pidstat -u 5 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 13:37:07      UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 13:37:12        0      2962  100.00    0.00    0.00    0.00  100.00     1  stress</span></span><br></pre></td></tr></table></figure>

<p>除此之外，还可以模拟 I/O 压力场景：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stress -i 1 --timeout 600</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时 mpstat 应参考 iowait、%sys</span></span><br></pre></td></tr></table></figure>

<p>或模拟大量进程的场景：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress -c 8 --timeout 600</span><br></pre></td></tr></table></figure>

<h2 id="使用率（Usage）"><a href="#使用率（Usage）" class="headerlink" title="使用率（Usage）"></a>使用率（Usage）</h2><p>CPU 使用率即除了空闲时间外的其他时间占总 CPU 时间的百分比（<code>== 1 - (空闲时间/总 CPU 时间)</code>）。</p>
<p>是单位时间内对 CPU 繁忙程度的统计，与平均负载不一定完全对应：</p>
<ul>
<li><p>  对于 CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时两者一致。</p>
</li>
<li><p>  对于 I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高。</p>
</li>
<li><p>  大量等待 CPU 的进程调度也会导致平均负载升高，此时 CPU 使用率也会比较高。</p>
</li>
</ul>
<h3 id="节拍率"><a href="#节拍率" class="headerlink" title="节拍率"></a>节拍率</h3><p>CPU 划分时间片，通过调度器轮流分配给多个进程使用，在宏观上可见进程同时运行。</p>
<p>其通过中断（Interrupt）维护时间片，按预定义的节拍率（内核选项 HZ，每秒触发中断数）触发中断，并使用全局变量 <code>Jiffies</code> 记录自启动起的节拍数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;CONFIG_HZ=&#x27; /boot/config-$(uname -r)</span><br><span class="line"><span class="meta">#</span><span class="bash"> CONFIG_HZ=250</span></span><br></pre></td></tr></table></figure>

<p>对于用户态进程，则参考用户态节拍率 <code>USER_HZ</code>（一般固定为 100）。</p>
<h3 id="CPU-统计信息"><a href="#CPU-统计信息" class="headerlink" title="CPU 统计信息"></a>CPU 统计信息</h3><p>通过 <code>/proc</code> 虚拟文件系统可以查看用户空间系统内部状态的信息，比如 CPU：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/stat | grep ^cpu</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /proc/[pid]/<span class="built_in">stat</span> 则取特定进程的数据。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cpu  280580 7407 286084 172900810 83602 0 583 0 0 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cpu0 144745 4181 176701 86423902 52076 0 301 0 0 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cpu1 135834 3226 109383 86476907 31525 0 282 0 0 0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  其每列的含义：</p>
<ul>
<li><p>  user（缩写 us），用户态 CPU 时间。它不包括 nice 时间，但包括了 guest 时间。</p>
</li>
<li><p>  nice（缩写 ni），低优先级用户态 CPU 时间。进程的 nice 值被调整为 1-19 之间时的 CPU 时间。nice 可取值范围是 -20 到 19，数值越大优先级越低。</p>
</li>
<li><p>  system（缩写 sys），内核态 CPU 时间。</p>
</li>
<li><p>  idle（缩写 id），空闲时间。不包括等待 I/O 的时间（iowait）。</p>
</li>
<li><p>  iowait（缩写 wa），等待 I/O 的 CPU 时间。</p>
</li>
<li><p>  irq（缩写 hi），处理硬中断的 CPU 时间。</p>
</li>
<li><p>  softirq（缩写 si），处理软中断的 CPU 时间。</p>
</li>
<li><p>  steal（缩写 st），当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。</p>
</li>
<li><p>  guest（缩写 guest），通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。</p>
</li>
<li><p>  guest_nice（缩写 gnice），以低优先级运行虚拟机的时间。</p>
</li>
</ul>
</blockquote>
<h3 id="如何监控？-1"><a href="#如何监控？-1" class="headerlink" title="如何监控？"></a>如何监控？</h3><p>不同的监控工具都是取某段时间的统计结果，但时间间隔可能不一样（<code>top</code> 默认 3s，<code>ps</code> 取进程整个生命周期）。使用 <code>ps</code> 命令查看整体情况（关注 %CPU 找到 CPU 占用高的进程）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line"><span class="meta">#</span><span class="bash"> top - 11:58:59 up 9 days, 22:47,  1 user,  load average: 0.03, 0.02, 0.00</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Tasks: 123 total,   1 running,  72 sleeping,   0 stopped,   0 zombie</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> %Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> KiB Mem :  8169348 total,  5606884 free,   334640 used,  2227824 buff/cache</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> KiB Swap:        0 total,        0 free,        0 used.  7497908 avail Mem</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     1 root      20   0   78088   9288   6696 S   0.0  0.1   0:16.83 systemd</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     2 root      20   0       0      0      0 S   0.0  0.0   0:00.05 kthreadd</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     4 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 kworker/0:0H</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 Task 一行可见处于各种状态的进程数量统计。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 %Cpu 一行可见总体情况，内核态、用户态、空闲百分比。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认为所有 CPU 平均值，输入 1 可切换为每个 CPU 使用率。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在每个进程的 %CPU 列，包括该用户态和内核态 CPU 使用率总和。</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>pidstat</code> 命令查看进程的具体情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pidstat 1 5</span><br><span class="line"><span class="meta">#</span><span class="bash"> 15:56:02      UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 15:56:03        0     15006    0.00    0.99    0.00    0.00    0.99     1  dockerd</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 平均值：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Average:      UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Average:        0     15006    0.00    0.99    0.00    0.00    0.99     -  dockerd</span></span><br><span class="line"></span><br><span class="line">pidstat -p 24344    # 查看某个进程的具体情况。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  其每列的含义：</p>
<ul>
<li><p>  用户态 CPU 使用率 （%usr）</p>
</li>
<li><p>  内核态 CPU 使用率（%system）</p>
</li>
<li><p>  运行虚拟机 CPU 使用率（%guest）</p>
</li>
<li><p>  等待 CPU 使用率（%wait）</p>
</li>
<li><p>  总 CPU 使用率（%CPU）。</p>
</li>
</ul>
</blockquote>
<h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><p>当 CPU 使用率过高，可以使用 perf 分析问题成因。</p>
<p>找出占用 CPU 时钟最多的函数或指令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">perf top</span><br><span class="line"><span class="meta">#</span><span class="bash"> 采样数、事件类型、事件总数。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Samples: 833  of event <span class="string">&#x27;cpu-clock&#x27;</span>, Event count (approx.): 97742399</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Overhead  Shared Object       Symbol</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    7.28%  perf                [.] 0x00000000001f78a4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    4.72%  [kernel]            [k] vsnprintf</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    4.32%  [kernel]            [k] module_get_kallsym</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    3.65%  [kernel]            [k] _raw_spin_unlock_irqrestore</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line"></span><br><span class="line">perf top -g -p 21515</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启调用关系的采样，方便根据调用链来分析性能问题，再查看具体的进程。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  其每列的含义：</p>
<ul>
<li><p>  Overhead 是该符号的性能事件在所有采样中的比例，百分比表示。</p>
</li>
<li><p>  Shared 是该函数或指令所在的动态共享对象（DSO），如内核、进程名、动态链接库名、内核模块名等。</p>
</li>
<li><p>  Object 是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间。</p>
</li>
<li><p>  Symbol 是符号名（函数名），当函数名未知时，用十六进制的地址来表示。</p>
</li>
</ul>
</blockquote>
<p>或实时展示系统性能信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">perf record -g</span><br><span class="line"><span class="meta">#</span><span class="bash"> [ perf record: Woken up 1 <span class="built_in">times</span> to write data ]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [ perf record: Captured and wrote 0.452 MB perf.data (6093 samples) ]</span></span><br><span class="line"></span><br><span class="line">perf report -g    # 输出报告</span><br></pre></td></tr></table></figure>

<p>在实践中：</p>
<ul>
<li><p>  用户 CPU（%user）和 Nice CPU（%nice）高，说明用户态进程占用了较多 CPU，着重排查进程性能问题。</p>
</li>
<li><p>  系统 CPU（%system）高，说明内核态占用了较多 CPU，着重排查内核线程或系统调用的性能问题。</p>
</li>
<li><p>  I/O 等待 CPU（%iowait）高，说明等待 I/O 的时间比较长，着排查系统存储是否出现 I/O 问题。</p>
</li>
<li><p>  软中断（%softirq）和硬中断（%irq）高，说明软中断或硬中断处理程序占用较多 CPU，着重排查内核中断服务程序。</p>
</li>
<li><p>当应用直接调用外部的二进制程序，或其本身在不断重启（可能是同名进程 pid 一直在改变），不会表现为某个进程 CPU 占用过高。</p>
<ul>
<li><p>  此时也许可以从其父进程中找到一些线索：<code>pstree | grep xxx</code>。</p>
</li>
<li><p>  结合 <code>perf record -g</code> 采集一段时间的数据，可见某同名进程占用的 CPU 时钟，确认是否导致 CPU 使用率高。 </p>
</li>
<li><p>  也可以使用 <code>execsnoop</code> 监控短时进程，通过 ftrace 实时监控进程的 exec() 行为输出进程 PID、父进程 PID、命令行参数以及执行的结果。</p>
</li>
</ul>
</li>
</ul>
<h2 id="上下文（Context）"><a href="#上下文（Context）" class="headerlink" title="上下文（Context）"></a>上下文（Context）</h2><p>上下文切换发生在进程竞争 CPU 时，即使此时进程没有运行，也会占用 CPU 负载。</p>
<p>CPU 时间片轮转分配给多任务，每个任务从何处加载、运行，依赖于事先保存在系统内核的上下文。在切换时新的任务上下文被加载到这些寄存器和程序计数器，再跳转到程序计数器所指的新位置来运行，因此上下文切换主要是更新 CPU 寄存器的值。</p>
<p>根据不同的场景，CPU 上下文切换分为进程上下文切换、线程上下文切换和中断上下文切换。</p>
<h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>按照特权等级，进程的运行空间分为 <strong>内核空间</strong> 和 <strong>用户空间</strong>，对应着图中 Ring 0 和 Ring 3。进程在内核空间运行时称为 <strong>内核态</strong>，在用户空间运行时称为 <strong>用户态</strong>。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------Ring3----- 应用</span><br><span class="line">|<span class="string"> +--------Ring2----- 设备驱动</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> +------Ring1----- 设备驱动</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> +----Ring0----- 内核</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|</span><br></pre></td></tr></table></figure>

<p>从用户态到内核态的转变，需要通过 <strong>系统调用</strong> 完成。系统调用是为 <strong>特权模式切换</strong> 而不是上下文切换，在一次系统调用中会发生两次 CPU 上下文切换：先保存起来 CPU 寄存器里原来用户态的指令位置。CPU 寄存器更新为内核态指令的新位置，最后跳转到内核态运行内核任务。而系统调用结束后，CPU 寄存器恢复原来保存的用户态，然后再切换到用户空间继续运行进程。</p>
<p>需要注意的是系统调用过程中一直是同一个进程在运行，不会涉及到虚拟内存等进程用户态的资源，也不会切换进程（区别于进程的上下文切换）。</p>
<blockquote>
<p>  进程上下文切换与系统调用的区别</p>
<p>  进程由内核来管理调度，进程切换只能发生在内核态。所以进程的上下文不仅包括虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。</p>
<p>  进程的上下文切换比系统调用时多了一步：先保存该进程的 <strong>虚拟内存、栈</strong> 等，再保存当前进程的 <strong>内核状态</strong> 和 <strong>CPU 寄存器</strong>；而加载了下一进程的内核态后，还需要 <strong>刷新进程的虚拟内存和用户栈</strong>。</p>
</blockquote>
<h4 id="切换的成本"><a href="#切换的成本" class="headerlink" title="切换的成本"></a>切换的成本</h4><p>每次上下文切换都需要几十纳秒到数微秒的 CPU 时间（<a target="_blank" rel="noopener" href="https://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html">Tsuna’s blog: How long does it take to make a context switch? (tsunanet.net)</a>）。特别是在进程上下文切换次数较多的情况下，容易导致 CPU 将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，大大缩短了真正运行进程的时间，导致平均负载升高。</p>
<p>Linux 通过 <strong>TLB（Translation Lookaside Buffer）</strong>管理虚拟内存到物理内存的映射关系。当虚拟内存更新后 TLB 也需要刷新，进程的内存访问随之变慢。在多处理器系统上缓存被多个处理器共享，刷新缓存还会影响共享缓存的其他处理器的进程。</p>
<h4 id="切换的时机"><a href="#切换的时机" class="headerlink" title="切换的时机"></a>切换的时机</h4><p>在进程调度时才需要切换上下文。Linux 为每个 CPU 都维护一个就绪队列，将活跃进程（Running or Runnable）按照优先级和等待 CPU 的时间排序，再选择优先级最高和等待 CPU 时间最长的进程来运行，比如：</p>
<ul>
<li><p>  进程执行完终止了，使用的 CPU 释放，此时再从就绪队列取出新进程运行。</p>
</li>
<li><p>  为了保证进程都被公平调度，CPU 划分一段段时间片，轮流分配给各个进程。某个进程的时间片耗尽就会被系统挂起，切换到其它进程运行。</p>
</li>
<li><p>  进程在系统资源不足（比如内存）时，要等到资源满足后才可以运行，此时进程会被挂起，由系统调度其他进程运行。</p>
</li>
<li><p>  进程通过 sleep 等函数将自己主动挂起，触发重新调度。</p>
</li>
<li><p>  有时为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。</p>
</li>
</ul>
<h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>进程是拥有资源的基本单位，线程是调度的基本单位：</p>
<ul>
<li><p>  当进程只有一个线程时，进程就等于线程。</p>
</li>
<li><p>  当进程拥有多个线程时，线程共享相同的虚拟内存和全局变量等资源（在上下文切换时不需要修改）。</p>
</li>
<li><p>  线程有自己的私有数据，比如栈和寄存器等（在上下文切换时需要保存）。</p>
</li>
</ul>
<p>线程上下文切换时，如果两个线程属于不同进程，切换过程就与进程上下文切换一样；如果属于同一进程，虚拟内存等资源保持不动，只切换线程的私有数据（寄存器等）。因此多线程比多进程开销更小。</p>
<h3 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h3><p>中断用于快速响应硬件事件，会打断进程的正常调度和执行，转而调用中断处理程序响应设备事件。而在打断其他进程时需要将进程状态保存，在中断结束后进程仍然可以从原状态恢复运行。</p>
<p>中断上下文切换不涉及到进程的用户态。即便中断过程打断正处在用户态的进程，不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。</p>
<p>在同一个 CPU 中中断处理比进程拥有更高的优先级，中断上下文切换不会与进程上下文切换同时发生。由于中断会打断正常进程的调度和执行，大部分中断处理程序都比较精简，以便尽可能快的执行结束。</p>
<p>中断上下文切换需要消耗 CPU，切换次数过多会严重降低系统的整体性能。</p>
<h3 id="压力测试-1"><a href="#压力测试-1" class="headerlink" title="压力测试"></a>压力测试</h3><p>安装 <code>sysbench</code> 和 <code>sysstat</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install -y sysbench sysstat</span><br></pre></td></tr></table></figure>

<p>模拟多线程调度的场景：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysbench --threads=10 --max-time=300 threads run    </span><br></pre></td></tr></table></figure>

<h3 id="如何监控？-2"><a href="#如何监控？-2" class="headerlink" title="如何监控？"></a>如何监控？</h3><p>使用 <code>vmstat</code> 命令查看总体情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vmstat 5</span><br><span class="line"><span class="meta">#</span><span class="bash"> procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  6  0      0 6487428 118240 1292772    0    0     0     0 9019 1398830 16 84  0  0  0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  8  0      0 6487428 118240 1292772    0    0     0     0 10191 1392312 16 84  0  0  0</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可见上下文切换次数 cs 139 万次，系统中断次数 <span class="keyword">in</span> 1 万次，绪队列长度 r 为 8。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  其每列的含义：</p>
<ul>
<li><p>  cs（context switch）是每秒上下文切换的次数。</p>
</li>
<li><p>  in（interrupt）则是每秒中断的次数。</p>
</li>
<li><p>  r（Running or Runnable）是就绪队列的长度，即正在运行和等待 CPU 的进程数，如果超出 CPU 核心数，表示竞争激烈。</p>
</li>
<li><p>  b（Blocked）是处于不可中断睡眠状态的进程数。</p>
</li>
<li><p>  us（user）和 sy（system）是用户态和内核态 CPU 使用率，表示 CPU 被内核或应用程序占用的情况。</p>
</li>
</ul>
</blockquote>
<p>使用 <code>pidstat</code> 具体到每个进程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pidstat -w -u -t 1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 08:06:33      UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 08:06:34        0     10488   30.00  100.00    0.00    0.00  100.00     0  sysbench</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 08:06:34        0     26326    0.00    1.00    0.00    0.00    1.00     0  kworker/u4:2</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 08:06:33      UID       PID   cswch/s nvcswch/s  Command</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 08:14:05        0     10551         -      6.00      0.00  sysbench</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 08:14:05        0         -     10551      6.00      0.00  |__sysbench</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 08:14:05        0         -     10552  18911.00 103740.00  |__sysbench</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 08:14:05        0         -     10553  18915.00 100955.00  |__sysbench</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 08:14:05        0         -     10554  18827.00 103954.00  |__sysbench</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  cswch 表示每秒自愿上下文切换（voluntary context switches）次数，指进程无法获取所需资源，导致的上下文切换。</li>
<li>  nvcswch 表示每秒非自愿上下文切换（non voluntary context switches）的次数，指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。</li>
</ul>
<p>可以在 <code>/proc/interrupts</code> 查看中断的详细信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch -d cat /proc/interrupts</span><br><span class="line"><span class="meta">#</span><span class="bash">            CPU0       CPU1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> RES:    2450431    5279697   Rescheduling interrupts</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure>

<p>RES 表示重调度中断，即唤醒空闲状态的 CPU 来调度新的任务运行。多处理器系统（SMP）中，调度器用于分散任务到不同 CPU 的机制，也被称为 <strong>处理器间中断（Inter-Processor Interrupts，IPI）</strong>。</p>
<h3 id="问题排查-1"><a href="#问题排查-1" class="headerlink" title="问题排查"></a>问题排查</h3><p>上下文切换频率取决于系统 CPU 性能。</p>
<ul>
<li><p>  如果系统上下文切换次数稳定，从数百到一万以内都正常。但当超过一万次或者切换次数出现数量级的增长，就可能已经出现性能问题。</p>
</li>
<li><p>  自愿上下文切换变多，说明进程在等待资源，可能发生 I/O 等问题；</p>
</li>
<li><p>  非自愿上下文切换变多，说明进程都在被强制调度、争抢 CPU，此时 CPU 称为瓶颈；</p>
</li>
<li><p>  中断次数变多，说明 CPU 被中断处理程序占用，还需要通过查看 <code>/proc/interrupts</code> 文件来分析具体中断类型。</p>
</li>
</ul>
<h2 id="异常进程"><a href="#异常进程" class="headerlink" title="异常进程"></a>异常进程</h2><p>通常指 <strong>不可中断进程</strong> 和 <strong>僵尸进程</strong>。</p>
<p>使用 <code>top</code> 命令可见 S 列（Status）表示进程的状态：</p>
<ul>
<li><p>  R（Running 或 Runnable）表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。</p>
</li>
<li><p>  D（Disk Sleep）表示不可中断状态睡眠（Uninterruptible Sleep），表示进程正在跟硬件交互，不允许被其他进程或中断打断。</p>
</li>
<li><p>  Z（Zombie）表示僵尸进程，即实际上已经结束了，但是父进程还没有回收其资源（比如进程的描述符、PID 等）的进程。</p>
</li>
<li><p>  S（Interruptible Sleep）是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。</p>
</li>
<li><p>  I（Idle）是空闲状态，用在不可中断睡眠的内核线程上。硬件交互导致不可中断进程用 D 表示，但某些内核线程可能并没有任何负载，则处于 I 状态。D 状态进程会导致平均负载升高， I 状态的进程不会。</p>
</li>
<li><p>  T 或者 t（Stopped 或 Traced）表示进程处于暂停或者跟踪状态。向一个进程发送 SIGSTOP 信号，就会因响应信号变成暂停状态（Stopped）；再向它发送 SIGCONT 信号，则又会恢复运行。或使用调试器（GDB 等）时，进程就会变成跟踪状态。</p>
</li>
<li><p>  X（Dead）表示进程已经消亡，不会在 <code>top</code> 或者 <code>ps</code> 命令中看到它。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line"><span class="meta">#</span><span class="bash">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 28961 root      20   0   43816   3148   4040 R   3.2  0.0   0:00.01 top</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   620 root      20   0   37280  33676    908 D   0.3  0.4   0:00.01 app</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     1 root      20   0  160072   9416   6752 S   0.0  0.1   0:37.64 systemd</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  1896 root      20   0       0      0      0 Z   0.0  0.0   0:00.00 devapp</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     2 root      20   0       0      0      0 S   0.0  0.0   0:00.10 kthreadd</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     4 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 kworker/0:0H</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     6 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 mm_percpu_wq</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     7 root      20   0       0      0      0 S   0.0  0.0   0:06.37 ksoftirqd/0</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Ss+ 中的 s 表示该进程是一个会话的领导进程，+ 表示前台进程组。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>进程组</strong>：表示一组相互关联的进程，比如每个子进程都是父进程所在组的成员。比如以 SSH 登录客户端，就会打开一个控制中断（TTY），控制终端对应一个会话（指共享同一个控制终端的一个或多个进程组）。在终端中运行命令以及其子进程，就构成了进程组，其中在后台运行的命令，构成后台进程组；在前台运行的命令，构成前台进程组。</p>
</blockquote>
<p><strong>不可中断进程（D）</strong>：当 iowait 升高时，进程很可能因为得不到硬件响应，长时间处于不可中断状态。短时间的不可中断状态一般可以忽略，但如果系统或硬件发生故障，进程可能在不可中断状态保持很久，导致在系统中大量出现。</p>
<h3 id="iowait-分析"><a href="#iowait-分析" class="headerlink" title="iowait 分析"></a>iowait 分析</h3><p>比如使用 <code>top</code> 查看系统资源使用情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line"><span class="meta">#</span><span class="bash"> top - 05:56:23 up 17 days, 16:45,  2 users,  load average: 2.00, 1.68, 1.39</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Tasks: 247 total,   1 running,  79 sleeping,   0 stopped, 115 zombie</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> %Cpu0  :  0.0 us,  0.7 sy,  0.0 ni, 38.9 id, 60.5 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> %Cpu1  :  0.0 us,  0.7 sy,  0.0 ni,  4.7 id, 94.6 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  4340 root      20   0   44676   4048   3432 R   0.3  0.0   0:00.05 top</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  4345 root      20   0   37280  33624    860 D   0.3  0.0   0:00.01 app</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  4344 root      20   0   37280  33624    860 D   0.3  0.4   0:00.01 app</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     1 root      20   0  160072   9416   6752 S   0.0  0.1   0:38.59 systemd</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure>

<p>以上输出中反映了几个问题：</p>
<ul>
<li><p>  过去 1 分钟、5 分钟和 15 分钟内的平均负载在依次减小，说明平均负载正在升高；而 1 分钟内的平均负载已经达到系统的 CPU 个数，说明系统很可能已经有了性能瓶颈。</p>
</li>
<li><p>  Tasks 中可见有 1 个正在运行的进程，但僵尸进程比较多且还在不停增加，说明有子进程在退出时没被清理。</p>
</li>
<li><p>  两个 CPU 的使用率：用户 CPU 和系统 CPU 都不高，但 iowait 高达 60.5% 和 94.6%。</p>
</li>
<li><p>  每个进程的情况： CPU 使用率最高的进程只有 0.3%，但有两个进程处于 D 状态，其可能在等待 I/O。</p>
</li>
</ul>
<p>可见 iowait 太高导致平均负载升高、达到系统 CPU 个数；僵尸进程在不断增多，有程序不能正确清理子进程的资源。使用 <code>dstat</code> 命令查看 CPU 和 I/O 使用情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dstat 1 10</span><br><span class="line"><span class="meta">#</span><span class="bash"> You did not select any stats, using -cdngy by default.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --total-cpu-usage-- -dsk/total- -net/total- ---paging-- ---system--</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> usr sys idl wai stl| <span class="built_in">read</span>  writ| recv  send|  <span class="keyword">in</span>   out | int   csw</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   0   0  96   4   0|1219k  408k|   0     0 |   0     0 |  42   885</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   0   0   2  98   0|  34M    0 | 198B  790B|   0     0 |  42   138</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   0   0   0 100   0|  34M    0 |  66B  342B|   0     0 |  42   135</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   0   0  84  16   0|5633k    0 |  66B  342B|   0     0 |  52   177</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   0   3  39  58   0|  22M    0 |  66B  342B|   0     0 |  43   144</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   0   0   0 100   0|  34M    0 | 200B  450B|   0     0 |  46   147</span></span><br></pre></td></tr></table></figure>

<p>可见每当 iowait 升高（wai）时，磁盘的读请求（read）都很大，说明 iowait 的升高与读磁盘有关。</p>
<p>对于在 <code>top</code> 的输出中状态为 D 的进程，使用 <code>pidstat</code> 命令查看 I/O 具体情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pidstat -d 1 20</span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 06:48:46      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 06:48:47        0      4615      0.00      0.00      0.00       1  kworker/u4:1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 06:48:47        0      6080  32768.00      0.00      0.00     170  app</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 06:48:47        0      6081  32768.00      0.00      0.00     184  app</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 06:48:47      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 06:48:48        0      6080      0.00      0.00      0.00     110  app</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure>

<p>其中 kB_rd 表示每秒读的 KB 数， kB_wr 表示每秒写的 KB 数，iodelay 表示 I/O 的延迟（时钟周期）。可见 app 进程在进行磁盘读，32 MB/s，重点是找到 app 进程的系统调用。</p>
<p>使用 <code>strace -p</code> 跟踪进程系统调用，前提是该进程未退出，不能是僵尸进程。因此更建议使用基于事件记录的动态追踪工具 <code>perf</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">perf record -g</span><br><span class="line">perf report</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重点观察 do_syscall 的操作。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  iowait 高不一定代表 I/O 有性能瓶颈。</p>
<p>  当 iowait 升高时，进程很可能因为得不到硬件的响应，而长时间处于不可中断状态。</p>
<p>  但当系统中只有 I/O 类型的进程在运行时 iowait 也会很高，实际上磁盘的读写远没有达到性能瓶颈的程度。</p>
<p>  因此还需要结合 dstat、pidstat 等工具确认是否磁盘 I/O 的问题，再找出导致 I/O 的进程。</p>
</blockquote>
<h3 id="处理僵尸进程"><a href="#处理僵尸进程" class="headerlink" title="处理僵尸进程"></a>处理僵尸进程</h3><p><strong>僵尸进程（Zombie）</strong>：正常情况下一个进程创建子进程后，应通过系统调用 <code>wait()</code> 或者 <code>waitpid()</code> 等待子进程结束并回收资源；子进程在结束时会向父进程发送 SIGCHLD 信号，父进程还可以注册 该信号的处理函数异步回收资源。如果父进程没回收资源或是子进程执行太快、父进程未来得及处理子进程状态就已经提前退出，子进程就会变成僵尸进程。此时 <code>mm_struct</code>、files 等都已释放，但需要保留 <code>task_struct</code>（即 PCB，程序控制块），通过父进程处理。通常僵尸进程持续的时间都比较短，在父进程回收其资源后就会消亡，或者在父进程退出后由 init 进程回收后也会消亡。</p>
<p>一旦父进程没有处理子进程的终止，还一直保持运行状态，子进程就会一直处于僵尸状态：</p>
<ul>
<li><p>  大量的僵尸进程会用尽 PID（进程号），导致不能创建新进程。</p>
</li>
<li><p>  另一方面是 <code>task_struct</code>会占用大量内存资源。</p>
</li>
</ul>
<p>处理僵尸进程需要先找出其父进程，使用 <code>pstree</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pstree -aps 3084</span><br><span class="line"><span class="meta">#</span><span class="bash"> systemd,1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   └─dockerd,15006 -H fd://</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       └─docker-containe,15024 --config /var/run/docker/containerd/containerd.toml</span></span><br><span class="line"><span class="meta">#</span><span class="bash">           └─docker-containe,3991 -namespace moby -workdir...</span></span><br><span class="line"><span class="meta">#</span><span class="bash">               └─app,4009</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                   └─(app,3084)</span></span><br></pre></td></tr></table></figure>

<p>可见 3084 进程的父进程是 4009，此时应查看 4009 进程的应用代码，子进程结束的处理是否正确：是否调用 <code>wait()</code> 或 <code>waitpid()</code>、有没有注册 SIGCHID 信号处理函数。</p>
<h2 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h2><p>中断（Interrupt）是系统响应硬件设备请求的异步事件处理机制，会打断进程的正常调度和执行，再调用内核中的中断处理程序来响应设备的请求。为了减少对正常进程运行调度的影响，中断处理程序就需要尽可能快地运行。其分为两个阶段：</p>
<ul>
<li><p>  <strong>硬中断</strong>：处理硬件请求，特点是快速执行，它在中断禁止模式下运行，主要处理与硬件紧密相关或时间敏感的工作（ <code>/proc/interrupts</code>）。</p>
</li>
<li><p>  <strong>软中断</strong>：由内核触发，特点是延迟执行。延迟处理上半部未完成的工作，通常以内核线程的方式运行（<code>/proc/softirqs</code>，包括 10 个类型 ）。除此之外，软中断还包括一些内核自定义的事件，比如内核调度和 RCU 锁（Read-Copy Update）等。</p>
</li>
</ul>
<blockquote>
<p>  比如网卡接收到数据包通过硬件中断的方式通知内核新数据就绪。</p>
<p>  硬中断：把网卡的数据读到内存中，更新硬件寄存器的状态，发送软中断信号。</p>
<p>  软中断：从内存中找到网络数据，再按照网络协议栈对数据进行逐层解析和处理，送给应用程序。</p>
</blockquote>
<p>软中断以内核线程运行，每个 CPU 对应一个软中断内核线程，即为 ksoftirqd/CPU 编号，使用 <code>ps</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep softirq</span><br><span class="line"><span class="meta">#</span><span class="bash"> root         7  0.0  0.0      0     0 ?        S    Oct10   0:01 [ksoftirqd/0]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> root        16  0.0  0.0      0     0 ?        S    Oct10   0:01 [ksoftirqd/1]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 线程名字外有中括号，表示 ps 无法获取命令行参数（cmline）。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一般来说在 ps 的输出中，名字括在中括号里的都是内核线程。</span></span><br></pre></td></tr></table></figure>

<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>软中断（softirq）CPU 使用率升高是最常见的一种性能问题，尤其是网络收发类型的软中断。</p>
<p>安装 hping3、tcpdump 网络协议包工具。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install -y hping3 tcpdump</span><br></pre></td></tr></table></figure>

<p>模拟 SYN FLOOD 攻击：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 -S -p 80 -i u100 192.168.0.30</span><br></pre></td></tr></table></figure>

<p>此时系统响应变慢，使用 <code>top</code> 查看总体情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line"><span class="meta">#</span><span class="bash"> top - 10:50:58 up 1 days, 22:10,  1 user,  load average: 0.00, 0.00, 0.00</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Tasks: 122 total,   1 running,  71 sleeping,   0 stopped,   0 zombie</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> %Cpu0  :  0.0 us,  0.0 sy,  0.0 ni, 96.7 id,  0.0 wa,  0.0 hi,  3.3 si,  0.0 st</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> %Cpu1  :  0.0 us,  0.0 sy,  0.0 ni, 95.6 id,  0.0 wa,  0.0 hi,  4.4 si,  0.0 st</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     7 root      20   0       0      0      0 S   0.3  0.0   0:01.64 ksoftirqd/0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    16 root      20   0       0      0      0 S   0.3  0.0   0:01.97 ksoftirqd/1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  2663 root      20   0  923480  28292  13996 S   0.3  0.3   4:58.66 docker-containe</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  3699 root      20   0       0      0      0 I   0.3  0.0   0:00.13 kworker/u4:0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure>

<p>在 <code>top</code> 的输出可见：</p>
<ul>
<li>  平均负载为 0，就绪队列里面只有一个进程（1 running）。</li>
<li>  每个 CPU 的使用率、所有进程的 CPU 使用率都比较低。</li>
</ul>
<p>其中 CPU 使用率最高的进程都是软中断线程，问题可能出现在软中断上。观察软中断次数的变化速率：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">watch -d cat /proc/softirqs</span><br><span class="line"><span class="meta">#</span><span class="bash">                     CPU0       CPU1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">           HI:          0          0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        TIMER:    1083906    2368646    定时中断</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       NET_TX:         53          9</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       NET_RX:    1550643    1916776    网络接收</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        BLOCK:          0          0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     IRQ_POLL:          0          0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">      TASKLET:     333637       3930</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        SCHED:     963675    2293171    内核调度</span></span><br><span class="line"><span class="meta">#</span><span class="bash">      HRTIMER:          0          0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">          RCU:    1542111    1590625    RCU 锁</span></span><br></pre></td></tr></table></figure>

<p>其中 NET_RX 变化特别快，可以初步确定是网络接收软中断出现问题，使用 <code>sar</code> 查看网络收发情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sar -n DEV 1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">                               PPS                      BPS</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 报告时间        网卡     每秒接收、发送的网络帧数  每秒接收、发送的千字节数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 15:03:46        IFACE     rxpck/s   txpck/s      rxkB/s    txkB/s      rxcmp/s   txcmp/s  rxmcst/s   %ifutil</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 15:03:47         eth0    12607.00   6304.00      664.86    358.11         0.00      0.00      0.00      0.01</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 15:03:47      docker0     6302.00  12604.00      270.79    664.66         0.00      0.00      0.00      0.00</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 15:03:47           lo        0.00      0.00        0.00      0.00         0.00      0.00      0.00      0.00</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 15:03:47    veth9f6bbcd   6302.00  12604.00      356.95    664.66         0.00      0.00      0.00      0.05</span></span><br></pre></td></tr></table></figure>

<p>可见 eth0 接收的 PPS 比较大（12607），而接收的 BPS 却很小（664KB/s），每个网络帧比较小（<code>664*1024/12607 == 54bytes</code>），因此是小包问题。使用 <code>tcpdump</code> 在 eth0 上抓包分析：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -n tcp port 80</span><br><span class="line"><span class="meta">#</span><span class="bash"> 15:11:32.678966 IP 192.168.0.2.18238 &gt; 192.168.0.30.80: Flags [S], seq 458303614, win 512, length 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure>

<p>可见包的源、目的 IP 和端口，而 Flags [S] 表示这是 SYN 包。SYN 包的 PPS 高达 20000，可见是 SYN FLOOD 攻击。</p>
<h2 id="缓存命中率"><a href="#缓存命中率" class="headerlink" title="缓存命中率"></a>缓存命中率</h2><p>CPU 采用多级缓存用于匹配与内存速度的差距：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+---------------------+</span></span><br><span class="line"><span class="section">|      L3 Cache       |</span></span><br><span class="line"><span class="section">+----------+----------+</span></span><br><span class="line"><span class="section">| L2 Cache | L2 Cache |</span></span><br><span class="line"><span class="section">+----------+----------+</span></span><br><span class="line"><span class="section">| L1 Cache | L1 Cache |</span></span><br><span class="line"><span class="section">+----------+----------+</span></span><br><span class="line"><span class="section">|  Core 0  |  Core 1  |</span></span><br><span class="line"><span class="section">+----------+----------+</span></span><br></pre></td></tr></table></figure>

<p>其中 L1 Cache、L2 Cache 在单核中，L3 则用在多核中。从 L1 到 L3，大小依次增大、性能依次降低。其命中率可衡量 CPU 缓存复用情况，命中率越高性能越好。</p>
<h2 id="工具总结"><a href="#工具总结" class="headerlink" title="工具总结"></a>工具总结</h2><p>要对系统 CPU 进行优化，可从应用和系统两个层面考虑了。其中系统优化：</p>
<ul>
<li><p>  <strong>CPU 绑定</strong>：把进程绑定到一或多个 CPU 上，可提高 CPU 缓存的命中率，减少跨 CPU 调度带来的上下文切换问题。</p>
</li>
<li><p>  <strong>CPU 独占</strong>：类似 CPU 绑定，进一步将 CPU 分组，通过 CPU 亲和性机制为其分配进程。这些 CPU 就由指定的进程独占，不允许其他进程使用。</p>
</li>
<li><p>  <strong>优先级调整</strong>：使用 nice 调整进程的优先级（正/负值调低/高）。适当降低非核心应用的优先级，增高核心应用的优先级，可确保核心应用得到优先处理。</p>
</li>
<li><p>  <strong>为进程设置资源限制</strong>：使用 Linux cgroups 设置进程 CPU 使用上限，可防止由于某个应用自身的问题而耗尽系统资源。</p>
</li>
<li><p>  <strong>NUMA（Non-Uniform Memory Access）</strong>优化：支持 NUMA 的处理器会被划分为多个 node，每个 node 都有自己的本地内存空间。就是让 CPU 尽可能只访问本地内存。</p>
</li>
<li><p>  <strong>中断负载均衡</strong>：中断处理程序可能会耗费大量的 CPU，开启 irqbalance 服务或者配置 smp_affinity，可以把中断处理过程自动负载均衡到多个 CPU 上。</p>
</li>
</ul>
<p>了解 CPU 相关概念与指标后，可通过下表找到合适的工具、分析问题。</p>
<img src="https://ywh-oss.oss-cn-shenzhen.aliyuncs.com/OS_linux-cpu-monitoring.assets/596397e1d6335d2990f70427ad4b14ec.png" alt="img" style="zoom:67%;" />

<img src="https://ywh-oss.oss-cn-shenzhen.aliyuncs.com/OS_linux-cpu-monitoring.assets/b0c67a7196f5ca4cc58f14f959a364ca.png" alt="img" style="zoom:67%;" />

<p><img src="https://ywh-oss.oss-cn-shenzhen.aliyuncs.com/OS_linux-cpu-monitoring.assets/7a445960a4bc0a58a02e1bc75648aa17.png" alt="img"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>分析案例可参考：</p>
<ul>
<li><p>  <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/70822">06 | 案例篇：系统的 CPU 使用率很高，但为啥却找不到高 CPU 的应用？</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/71064">07 | 案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（上）</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/71382">08 | 案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（下）</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/72147">10 | 案例篇：系统的软中断CPU使用率升高，我该怎么办？</a></p>
</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    </article>
    <!-- license  -->
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2021/04/20/OS_linux-io-monitoring/" title= "Linux I/O 原理与分析">
                    <div class="nextTitle">Linux I/O 原理与分析</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2021/04/01/OS_system_initialization/" title= "Linux - 架构与系统初始化">
                    <div class="prevTitle">Linux - 架构与系统初始化</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

    <div id="lv-container" data-id="city" data-uid= MTAyMC80ODYzMi8yNTEyNg==>
        <script type="text/javascript">
            (function (d, s) {
                var j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') { return; }
                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

<!-- City版安装代码已完成 -->
    
    
     
    <!-- utteranc评论 -->

    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->

    <!-- idea from: https://hexo.fluid-dev.com/posts/hexo-injector/#%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%80%A7%E6%8F%90%E7%A4%BA -->
    
</main>

            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:yipwinghong@outlook.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/yipwinghong" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                    
                    <img class="profile-qr" src="https://ywh-oss.oss-cn-shenzhen.aliyuncs.com/WeChat.jpg" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="https://www.v2ex.com/member/yipwinghong" class="iconfont-archer v2ex" target="_blank" title=v2ex></a>
            
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title=rss></a>
            
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- website approve for Chinese user -->
    
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:100vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-CPU-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">Linux CPU 原理与分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD%EF%BC%88Load-Average%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">平均负载（Load Average）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">如何监控？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">压力测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%8E%87%EF%BC%88Usage%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">使用率（Usage）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E6%8B%8D%E7%8E%87"><span class="toc-number">1.2.1.</span> <span class="toc-text">节拍率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.2.</span> <span class="toc-text">CPU 统计信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%EF%BC%9F-1"><span class="toc-number">1.2.3.</span> <span class="toc-text">如何监控？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">1.2.4.</span> <span class="toc-text">问题排查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%88Context%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">上下文（Context）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.3.1.</span> <span class="toc-text">进程上下文切换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">切换的成本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">切换的时机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.3.2.</span> <span class="toc-text">线程上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.3.3.</span> <span class="toc-text">中断上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95-1"><span class="toc-number">1.3.4.</span> <span class="toc-text">压力测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%EF%BC%9F-2"><span class="toc-number">1.3.5.</span> <span class="toc-text">如何监控？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-1"><span class="toc-number">1.3.6.</span> <span class="toc-text">问题排查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">异常进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#iowait-%E5%88%86%E6%9E%90"><span class="toc-number">1.4.1.</span> <span class="toc-text">iowait 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">处理僵尸进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">1.5.</span> <span class="toc-text">软中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">1.5.1.</span> <span class="toc-text">问题分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD%E7%8E%87"><span class="toc-number">1.6.</span> <span class="toc-text">缓存命中率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">工具总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.8.</span> <span class="toc-text">参考</span></a></li></ol></li></ol>
    </div>
    
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 63
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2021 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/18</span><a class="archive-post-title" href= "/2021/07/18/Go_error_handling/" >Go 异常处理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/12</span><a class="archive-post-title" href= "/2021/07/12/Go_microservice/" >微服务概览与治理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/09</span><a class="archive-post-title" href= "/2021/07/09/Algorithm_max-flow-problem/" >最大流问题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/08</span><a class="archive-post-title" href= "/2021/07/08/Algorithm_minimum_spanning_tree_problem/" >最小生成树问题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/08</span><a class="archive-post-title" href= "/2021/07/08/Algorithm_shortest-path-problem/" >最短路径问题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/01</span><a class="archive-post-title" href= "/2021/07/01/DistributedSystem_gossip-dissemination/" >分布式系统模式：Gossip 传播</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/23</span><a class="archive-post-title" href= "/2021/06/23/DistributedSystem_versioned-value/" >分布式系统模式：版本化值</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/19</span><a class="archive-post-title" href= "/2021/06/19/Algorithm_consistent-hashing/" >一致性哈希</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/13</span><a class="archive-post-title" href= "/2021/06/13/Go_cheat-sheet/" >Go Cheat Sheet</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/06</span><a class="archive-post-title" href= "/2021/06/06/2021-06-06_diary/" >Weekly Summary (2021-05-31_2021-06-06)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/05</span><a class="archive-post-title" href= "/2021/06/05/2021-06-05_diary/" >基于记忆规律的学习方法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/31</span><a class="archive-post-title" href= "/2021/05/31/2021-05-31_diary/" >2021 下半年工作学习安排</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/16</span><a class="archive-post-title" href= "/2021/05/16/Algorithm_how-to-solve-the-secret-santa-problem-using-graph-theory/" >如何用图论解决 Secret Santa 问题？</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/12</span><a class="archive-post-title" href= "/2021/05/12/DB_using-postgresql-as-a-data-warehouse/" >把 PostgreSQL 用作数据仓库</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/28</span><a class="archive-post-title" href= "/2021/04/28/OS_linux-memory-monitoring/" >Linux 内存原理与分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/20</span><a class="archive-post-title" href= "/2021/04/20/OS_linux-io-monitoring/" >Linux I/O 原理与分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/16</span><a class="archive-post-title" href= "/2021/04/16/OS_linux-cpu-monitoring/" >Linux CPU 原理与分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/01</span><a class="archive-post-title" href= "/2021/04/01/OS_system_initialization/" >Linux - 架构与系统初始化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/17</span><a class="archive-post-title" href= "/2021/03/17/Java_cpp-for-java-programmers/" >Java 程序员的 C++</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/24</span><a class="archive-post-title" href= "/2021/02/24/DDIA_note-13/" >《DDIA》阅读笔记（九）：一致性与共识（共识问题）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/21</span><a class="archive-post-title" href= "/2021/02/21/2021-02-21_diary/" >近期工作学习规划</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/19</span><a class="archive-post-title" href= "/2021/02/19/DDIA_note-12/" >《DDIA》阅读笔记（九）：一致性与共识（顺序保证）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/13</span><a class="archive-post-title" href= "/2021/02/13/DDIA_note-11/" >《DDIA》阅读笔记（九）：一致性与共识（可线性化）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/06</span><a class="archive-post-title" href= "/2021/02/06/DDIA_note-10/" >《DDIA》阅读笔记（八）：分布式系统的挑战</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/27</span><a class="archive-post-title" href= "/2021/01/27/DDIA_note-9/" >《DDIA》阅读笔记（七）：事务</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/22</span><a class="archive-post-title" href= "/2021/01/22/DDIA_note-8/" >《DDIA》阅读笔记（六）：数据分区</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/21</span><a class="archive-post-title" href= "/2021/01/21/DDIA_note-7/" >《DDIA》阅读笔记（五）：数据复制（无主节点）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/20</span><a class="archive-post-title" href= "/2021/01/20/DDIA_note-6/" >《DDIA》阅读笔记（五）：数据复制（多主节点）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/10</span><a class="archive-post-title" href= "/2021/01/10/DB_right-database/" >选择合适的数据库</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/09</span><a class="archive-post-title" href= "/2021/01/09/DDIA_note-5/" >《DDIA》阅读笔记（五）：数据复制（单主节点）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/01</span><a class="archive-post-title" href= "/2021/01/01/DB_tree-table-design-summary/" >树形表结构设计总结</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/19</span><a class="archive-post-title" href= "/2020/12/19/DDIA_note-4/" >《DDIA》阅读笔记（四）：数据编码与演化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/13</span><a class="archive-post-title" href= "/2020/12/13/DDIA_note-3/" >《DDIA》阅读笔记（三）：数据存储与检索</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/04</span><a class="archive-post-title" href= "/2020/12/04/DDIA_note-2/" >《DDIA》阅读笔记（二）：数据模型与查询语言</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/02</span><a class="archive-post-title" href= "/2020/12/02/DDIA_note-1/" >《DDIA》阅读笔记（一）：可靠、可扩展与可维护的应用系统</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/08</span><a class="archive-post-title" href= "/2020/10/08/Maven_external_dependencies_management/" >Maven 打包依赖外置</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/04</span><a class="archive-post-title" href= "/2020/10/04/JVM_prod-analysis-cmd/" >Java 应用常用调试分析方法总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/24</span><a class="archive-post-title" href= "/2020/09/24/Kafka_cheat-sheet/" >Kafka Cheat Sheet</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/09</span><a class="archive-post-title" href= "/2020/08/09/Arthas_Cheat-Sheet/" >Arthas Cheat Sheet</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/12</span><a class="archive-post-title" href= "/2020/07/12/Java_override-and-bridge-method/" >Java 多态、重写与桥接方法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/30</span><a class="archive-post-title" href= "/2020/06/30/JVM_java-memory-area/" >Java 内存区域</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/28</span><a class="archive-post-title" href= "/2020/05/28/DB_data-warehouse-design-basic/" >数据仓库设计基础</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/08</span><a class="archive-post-title" href= "/2020/04/08/2020-04-08_diary/" >关于使用思维导图做笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/28</span><a class="archive-post-title" href= "/2020/03/28/Algorithm_leetcode-high-frequency-problems/" >LeetCode 高频面试题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/06</span><a class="archive-post-title" href= "/2020/03/06/InfoSecty_personal-infomation-security-guide/" >個人信息安全保護指南</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/22</span><a class="archive-post-title" href= "/2020/02/22/2020-02-22_diary/" >免费 JetBrains 全家桶</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/16</span><a class="archive-post-title" href= "/2020/02/16/Nginx_cheat-sheet/" >Nginx Cheat Sheet</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/15</span><a class="archive-post-title" href= "/2020/02/15/Git_Cheat-Sheet/" >Git Cheat Sheet</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/15</span><a class="archive-post-title" href= "/2020/02/15/Docker&K8S_Cheat-Sheet/" >Docker & K8S Cheat Sheet</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/03</span><a class="archive-post-title" href= "/2020/02/03/JVM_jstat-monitor-analysis/" >JVM jstat 监控分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/01</span><a class="archive-post-title" href= "/2020/02/01/JVM_GC-log-analysis/" >JVM GC 日志分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/01</span><a class="archive-post-title" href= "/2020/01/01/JVM_mindmap/" >Java 虚拟机与并发编程</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/05</span><a class="archive-post-title" href= "/2019/12/05/Design_design-patterns/" >设计模式与设计原则</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/04</span><a class="archive-post-title" href= "/2019/10/04/Python_async-programming/" >Python 异步编程总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/19</span><a class="archive-post-title" href= "/2019/09/19/Python_data-structure/" >Python 数据结构应用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/13</span><a class="archive-post-title" href= "/2019/09/13/Python_decorator-basic-usage/" >Python 装饰器基本用法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/22</span><a class="archive-post-title" href= "/2019/08/22/Python_OOP-summary/" >Python 类与对象总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/28</span><a class="archive-post-title" href= "/2019/06/28/JavaScript_cheat-sheet/" >JavaScript Cheat Sheet</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/02</span><a class="archive-post-title" href= "/2019/06/02/JavaScript_ES6-grammar/" >ES6 语法总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/30</span><a class="archive-post-title" href= "/2019/05/30/Vue_user-guide-4/" >Vue 学习笔记：前端路由、请求发送和状态管理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/24</span><a class="archive-post-title" href= "/2019/05/24/Vue_user-guide-3/" >Vue 学习笔记：组件</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/23</span><a class="archive-post-title" href= "/2019/05/23/Vue_user-guide-2/" >Vue 学习笔记（2）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/20</span><a class="archive-post-title" href= "/2019/05/20/Vue_user-guide-1/" >Vue 学习笔记（1）</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="技术"><span class="iconfont-archer">&#xe606;</span>技术</span>
    
        <span class="sidebar-tag-name" data-tags="杂事"><span class="iconfont-archer">&#xe606;</span>杂事</span>
    
        <span class="sidebar-tag-name" data-tags="算法"><span class="iconfont-archer">&#xe606;</span>算法</span>
    
        <span class="sidebar-tag-name" data-tags="Java"><span class="iconfont-archer">&#xe606;</span>Java</span>
    
        <span class="sidebar-tag-name" data-tags="大数据"><span class="iconfont-archer">&#xe606;</span>大数据</span>
    
        <span class="sidebar-tag-name" data-tags="数据库"><span class="iconfont-archer">&#xe606;</span>数据库</span>
    
        <span class="sidebar-tag-name" data-tags="设计"><span class="iconfont-archer">&#xe606;</span>设计</span>
    
        <span class="sidebar-tag-name" data-tags="分布式系统"><span class="iconfont-archer">&#xe606;</span>分布式系统</span>
    
        <span class="sidebar-tag-name" data-tags="Docker"><span class="iconfont-archer">&#xe606;</span>Docker</span>
    
        <span class="sidebar-tag-name" data-tags="Kubernetes"><span class="iconfont-archer">&#xe606;</span>Kubernetes</span>
    
        <span class="sidebar-tag-name" data-tags="信息安全"><span class="iconfont-archer">&#xe606;</span>信息安全</span>
    
        <span class="sidebar-tag-name" data-tags="Maven"><span class="iconfont-archer">&#xe606;</span>Maven</span>
    
        <span class="sidebar-tag-name" data-tags="Nginx"><span class="iconfont-archer">&#xe606;</span>Nginx</span>
    
        <span class="sidebar-tag-name" data-tags="Linux"><span class="iconfont-archer">&#xe606;</span>Linux</span>
    
        <span class="sidebar-tag-name" data-tags="OS"><span class="iconfont-archer">&#xe606;</span>OS</span>
    
        <span class="sidebar-tag-name" data-tags="Python"><span class="iconfont-archer">&#xe606;</span>Python</span>
    
        <span class="sidebar-tag-name" data-tags="Vue"><span class="iconfont-archer">&#xe606;</span>Vue</span>
    
        <span class="sidebar-tag-name" data-tags="前端"><span class="iconfont-archer">&#xe606;</span>前端</span>
    
        <span class="sidebar-tag-name" data-tags="Git"><span class="iconfont-archer">&#xe606;</span>Git</span>
    
        <span class="sidebar-tag-name" data-tags="Go"><span class="iconfont-archer">&#xe606;</span>Go</span>
    
        <span class="sidebar-tag-name" data-tags="微服务"><span class="iconfont-archer">&#xe606;</span>微服务</span>
    
        <span class="sidebar-tag-name" data-tags="JavaScript"><span class="iconfont-archer">&#xe606;</span>JavaScript</span>
    
        <span class="sidebar-tag-name" data-tags="Kafka"><span class="iconfont-archer">&#xe606;</span>Kafka</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="《数据密集型应用系统设计》阅读笔记"><span class="iconfont-archer">&#xe60a;</span>《数据密集型应用系统设计》阅读笔记</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Kylo Yip"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>


